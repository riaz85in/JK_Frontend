{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { getNameFromFilePath, matchDeepDynamicRouteName, matchDynamicName, matchGroupName, removeSupportedExtensions, stripGroupSegmentsFromPath } from \"./matchers\";\nexport function getRecursiveTree(files) {\n  var tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null\n  };\n  for (var file of files) {\n    var parts = file.normalizedName.split(\"/\");\n    var currentNode = tree;\n    var _loop = function _loop() {\n      var part = parts[i];\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          var overwritten = currentNode.node.contextKey;\n          throw new Error(\"Higher priority Layout Route \\\"\" + file.contextKey + \"\\\" overriding redundant Layout Route \\\"\" + overwritten + \"\\\". Remove the Layout Route \\\"\" + overwritten + \"\\\" to fix this.\");\n        }\n        return \"continue\";\n      }\n      var existing = currentNode.children.find(function (item) {\n        return item.name === part;\n      });\n      if (existing) {\n        currentNode = existing;\n      } else {\n        var newNode = {\n          name: part,\n          children: [],\n          parents: [].concat(_toConsumableArray(currentNode.parents), [currentNode.name]),\n          node: null\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    };\n    for (var i = 0; i < parts.length; i++) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n    currentNode.node = file;\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n  return tree;\n}\nfunction assertDeprecatedFormat(tree) {\n  for (var child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith(\"_layout\")) {\n      var ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(\"Using deprecated Layout Route format: Move `./app/\" + child.node.normalizedName + \".\" + ext + \"` to `./app/\" + child.node.normalizedName + \"/_layout.\" + ext + \"`\");\n    }\n    assertDeprecatedFormat(child);\n  }\n}\nfunction getTreeNodesAsRouteNodes(nodes) {\n  return nodes.map(treeNodeToRouteNode).flat().filter(Boolean);\n}\nexport function generateDynamicFromSegment(name) {\n  var deepDynamicName = matchDeepDynamicRouteName(name);\n  var dynamicName = deepDynamicName != null ? deepDynamicName : matchDynamicName(name);\n  return dynamicName ? {\n    name: dynamicName,\n    deep: !!deepDynamicName\n  } : null;\n}\nexport function generateDynamic(name) {\n  var description = name.split(\"/\").map(function (segment) {\n    return generateDynamicFromSegment(segment);\n  }).filter(Boolean);\n  return description.length === 0 ? null : description;\n}\nfunction collapseRouteSegments(route) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\nfunction getDefaultInitialRoute(node, name) {\n  return node.children.find(function (node) {\n    return collapseRouteSegments(node.route) === name;\n  });\n}\nfunction applyDefaultInitialRouteName(node) {\n  var _node$children, _getDefaultInitialRou;\n  var groupName = matchGroupName(node.route);\n  if (!((_node$children = node.children) != null && _node$children.length)) {\n    return node;\n  }\n  var initialRouteName = groupName ? (_getDefaultInitialRou = getDefaultInitialRoute(node, groupName)) == null ? void 0 : _getDefaultInitialRou.route : undefined;\n  var loaded = node.loadRoute();\n  if (loaded.unstable_settings) {\n    var _loaded$unstable_sett;\n    initialRouteName = (_loaded$unstable_sett = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett : initialRouteName;\n    if (groupName) {\n      var _loaded$unstable_sett2, _loaded$unstable_sett3;\n      var groupSpecificInitialRouteName = (_loaded$unstable_sett2 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett3 = _loaded$unstable_sett2[groupName]) == null ? void 0 : _loaded$unstable_sett3.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n    }\n  }\n  return _objectSpread(_objectSpread({}, node), {}, {\n    initialRouteName: initialRouteName\n  });\n}\nfunction cloneGroupRoute(node, _ref) {\n  var nextName = _ref.name;\n  var groupName = \"(\" + nextName + \")\";\n  var parts = node.contextKey.split(\"/\");\n  parts[parts.length - 2] = groupName;\n  return _objectSpread(_objectSpread({}, node), {}, {\n    route: groupName,\n    contextKey: parts.join(\"/\")\n  });\n}\nfunction treeNodeToRouteNode(_ref2) {\n  var name = _ref2.name,\n    node = _ref2.node,\n    children = _ref2.children;\n  var dynamic = generateDynamic(name);\n  if (node) {\n    var groupName = matchGroupName(name);\n    var multiGroup = groupName == null ? void 0 : groupName.includes(\",\");\n    var clones = multiGroup ? groupName.split(\",\").map(function (v) {\n      return {\n        name: v.trim()\n      };\n    }) : null;\n    if (clones) {\n      var names = new Set();\n      for (var clone of clones) {\n        if (names.has(clone.name)) {\n          throw new Error(\"Array syntax cannot contain duplicate group name \\\"\" + clone.name + \"\\\" in \\\"\" + node.contextKey + \"\\\".\");\n        }\n        names.add(clone.name);\n      }\n    }\n    var output = {\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic: dynamic\n    };\n    if (Array.isArray(clones)) {\n      return clones.map(function (clone) {\n        return applyDefaultInitialRouteName(cloneGroupRoute(_objectSpread({}, output), clone));\n      });\n    }\n    return [applyDefaultInitialRouteName({\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic: dynamic\n    })];\n  }\n  if (!children.length) {\n    return null;\n  }\n  return getTreeNodesAsRouteNodes(children.map(function (child) {\n    return _objectSpread(_objectSpread({}, child), {}, {\n      name: [name, child.name].filter(Boolean).join(\"/\")\n    });\n  }));\n}\nfunction contextModuleToFileNodes(contextModule) {\n  var nodes = contextModule.keys().map(function (key) {\n    try {\n      var _contextModule;\n      if (!((_contextModule = contextModule(key)) != null && _contextModule.default)) {\n        return null;\n      }\n    } catch (error) {\n      console.warn('Error loading route \"' + key + '\"', error);\n      return null;\n    }\n    var node = {\n      loadRoute: function loadRoute() {\n        return contextModule(key);\n      },\n      normalizedName: getNameFromFilePath(key),\n      contextKey: key\n    };\n    return node;\n  });\n  return nodes.filter(Boolean);\n}\nfunction hasCustomRootLayoutNode(routes) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  var route = routes[0];\n  if (route.route === \"\" && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\nfunction treeNodesToRootRoute(treeNode) {\n  var routes = treeNodeToRouteNode(treeNode);\n  if (!(routes != null && routes.length)) {\n    return null;\n  }\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n  return {\n    loadRoute: function loadRoute() {\n      return {\n        default: require(\"./views/Navigator\").DefaultNavigator\n      };\n    },\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n    generated: true,\n    dynamic: null,\n    children: routes\n  };\n}\nexport function assertDuplicateRoutes(filenames) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n  var duplicates = filenames.map(function (filename) {\n    return removeSupportedExtensions(filename);\n  }).reduce(function (acc, filename) {\n    acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n    return acc;\n  }, {});\n  Object.entries(duplicates).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      filename = _ref4[0],\n      count = _ref4[1];\n    if (count > 1) {\n      throw new Error(\"Multiple files match the route name \\\"\" + filename + \"\\\".\");\n    }\n  });\n}\nexport function getRoutes(contextModule) {\n  var route = getExactRoutes(contextModule);\n  if (!route) {\n    return null;\n  }\n  appendSitemapRoute(route);\n  appendUnmatchedRoute(route);\n  return route;\n}\nexport function getExactRoutes(contextModule) {\n  assertDuplicateRoutes(contextModule.keys());\n  var files = contextModuleToFileNodes(contextModule);\n  var treeNodes = getRecursiveTree(files);\n  var route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\nfunction appendSitemapRoute(routes) {\n  if (!routes.children.length || routes.children.some(function (route) {\n    return route.route === \"_sitemap\";\n  })) {\n    return routes;\n  }\n  var _require = require(\"./views/Sitemap\"),\n    Sitemap = _require.Sitemap,\n    getNavOptions = _require.getNavOptions;\n  routes.children.push({\n    loadRoute: function loadRoute() {\n      return {\n        default: Sitemap,\n        getNavOptions: getNavOptions\n      };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: []\n  });\n  return routes;\n}\nfunction appendUnmatchedRoute(routes) {\n  var userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute: function loadRoute() {\n        return {\n          default: require(\"./views/Unmatched\").Unmatched\n        };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{\n        name: \"404\",\n        deep: true\n      }],\n      children: [],\n      generated: true,\n      internal: true\n    });\n  }\n  return routes;\n}\nexport function getUserDefinedDeepDynamicRoute(routes) {\n  for (var route of (_routes$children = routes.children) != null ? _routes$children : []) {\n    var _routes$children;\n    var isDeepDynamic = matchDeepDynamicRouteName(route.route);\n    if (isDeepDynamic) {\n      return route;\n    }\n    if (matchGroupName(route.route)) {\n      var child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["getNameFromFilePath","matchDeepDynamicRouteName","matchDynamicName","matchGroupName","removeSupportedExtensions","stripGroupSegmentsFromPath","getRecursiveTree","files","tree","name","children","parents","node","file","parts","normalizedName","split","currentNode","_loop","part","i","length","overwritten","contextKey","Error","existing","find","item","newNode","concat","_toConsumableArray","push","_ret","process","env","NODE_ENV","assertDeprecatedFormat","child","endsWith","ext","pop","getTreeNodesAsRouteNodes","nodes","map","treeNodeToRouteNode","flat","filter","Boolean","generateDynamicFromSegment","deepDynamicName","dynamicName","deep","generateDynamic","description","segment","collapseRouteSegments","route","replace","getDefaultInitialRoute","applyDefaultInitialRouteName","_node$children","_getDefaultInitialRou","groupName","initialRouteName","undefined","loaded","loadRoute","unstable_settings","_loaded$unstable_sett","_loaded$unstable_sett2","_loaded$unstable_sett3","groupSpecificInitialRouteName","_objectSpread","cloneGroupRoute","_ref","nextName","join","_ref2","dynamic","multiGroup","includes","clones","v","trim","names","Set","clone","has","add","output","Array","isArray","contextModuleToFileNodes","contextModule","keys","key","_contextModule","default","error","console","warn","hasCustomRootLayoutNode","routes","match","treeNodesToRootRoute","treeNode","require","DefaultNavigator","generated","assertDuplicateRoutes","filenames","duplicates","filename","reduce","acc","Object","entries","forEach","_ref3","_ref4","_slicedToArray","count","getRoutes","getExactRoutes","appendSitemapRoute","appendUnmatchedRoute","treeNodes","some","_require","Sitemap","getNavOptions","internal","userDefinedDynamicRoute","getUserDefinedDeepDynamicRoute","Unmatched","_routes$children","isDeepDynamic"],"sources":["C:/Riaz/Projects/JK/JK_Frontend/node_modules/expo-router/src/getRoutes.ts"],"sourcesContent":["import { DynamicConvention, RouteNode } from \"./Route\";\nimport {\n  getNameFromFilePath,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n  stripGroupSegmentsFromPath,\n} from \"./matchers\";\nimport { RequireContext } from \"./types\";\n\nexport type FileNode = Pick<RouteNode, \"contextKey\" | \"loadRoute\"> & {\n  /** Like `(tab)/index` */\n  normalizedName: string;\n};\n\ntype TreeNode = {\n  name: string;\n  children: TreeNode[];\n  parents: string[];\n  /** null when there is no file in a folder. */\n  node: FileNode | null;\n};\n\n/** Convert a flat map of file nodes into a nested tree of files. */\nexport function getRecursiveTree(files: FileNode[]): TreeNode {\n  const tree = {\n    name: \"\",\n    children: [],\n    parents: [],\n    node: null,\n  };\n\n  for (const file of files) {\n    // ['(tab)', 'settings', '[...another]']\n    const parts = file.normalizedName.split(\"/\");\n    let currentNode: TreeNode = tree;\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      if (i === parts.length - 1 && part === \"_layout\") {\n        if (currentNode.node) {\n          const overwritten = currentNode.node.contextKey;\n          throw new Error(\n            `Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`\n          );\n        }\n        continue;\n      }\n\n      const existing = currentNode.children.find((item) => item.name === part);\n      if (existing) {\n        currentNode = existing;\n      } else {\n        const newNode: TreeNode = {\n          name: part,\n          children: [],\n          parents: [...currentNode.parents, currentNode.name],\n          node: null,\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    }\n    currentNode.node = file;\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDeprecatedFormat(tree);\n  }\n\n  return tree;\n}\n\nfunction assertDeprecatedFormat(tree: TreeNode) {\n  for (const child of tree.children) {\n    if (\n      child.node &&\n      child.children.length &&\n      !child.node.normalizedName.endsWith(\"_layout\")\n    ) {\n      const ext = child.node.contextKey.split(\".\").pop();\n      throw new Error(\n        `Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``\n      );\n    }\n    assertDeprecatedFormat(child);\n  }\n}\n\nfunction getTreeNodesAsRouteNodes(nodes: TreeNode[]): RouteNode[] {\n  return nodes.map(treeNodeToRouteNode).flat().filter(Boolean) as RouteNode[];\n}\n\nexport function generateDynamicFromSegment(\n  name: string\n): DynamicConvention | null {\n  const deepDynamicName = matchDeepDynamicRouteName(name);\n  const dynamicName = deepDynamicName ?? matchDynamicName(name);\n\n  return dynamicName ? { name: dynamicName, deep: !!deepDynamicName } : null;\n}\n\nexport function generateDynamic(name: string): RouteNode[\"dynamic\"] {\n  const description = name\n    .split(\"/\")\n    .map((segment) => generateDynamicFromSegment(segment))\n    .filter(Boolean) as DynamicConvention[];\n  return description.length === 0 ? null : description;\n}\n\nfunction collapseRouteSegments(route: string) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, \"\"));\n}\n\n/**\n * Given a route node and a name representing the group name,\n * find the nearest child matching the name.\n *\n * Doesn't support slashes in the name.\n * Routes like `explore/(something)/index` will be matched against `explore`.\n *\n */\nfunction getDefaultInitialRoute(node: RouteNode, name: string) {\n  return node.children.find(\n    (node) => collapseRouteSegments(node.route) === name\n  );\n}\n\nfunction applyDefaultInitialRouteName(node: RouteNode): RouteNode {\n  const groupName = matchGroupName(node.route);\n  if (!node.children?.length) {\n    return node;\n  }\n\n  // Guess at the initial route based on the group name.\n  // TODO(EvanBacon): Perhaps we should attempt to warn when the group doesn't match any child routes.\n  let initialRouteName = groupName\n    ? getDefaultInitialRoute(node, groupName)?.route\n    : undefined;\n  const loaded = node.loadRoute();\n\n  if (loaded.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName =\n      loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName =\n        loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    initialRouteName,\n  };\n}\n\nfunction cloneGroupRoute(\n  node: RouteNode,\n  { name: nextName }: { name: string }\n): RouteNode {\n  const groupName = `(${nextName})`;\n  const parts = node.contextKey.split(\"/\");\n  parts[parts.length - 2] = groupName;\n\n  return {\n    ...node,\n    route: groupName,\n    contextKey: parts.join(\"/\"),\n  };\n}\n\nfunction treeNodeToRouteNode({\n  name,\n  node,\n  children,\n}: TreeNode): RouteNode[] | null {\n  const dynamic = generateDynamic(name);\n\n  if (node) {\n    const groupName = matchGroupName(name);\n    const multiGroup = groupName?.includes(\",\");\n\n    const clones = multiGroup\n      ? groupName!.split(\",\").map((v) => ({ name: v.trim() }))\n      : null;\n\n    // Assert duplicates:\n    if (clones) {\n      const names = new Set<string>();\n      for (const clone of clones) {\n        if (names.has(clone.name)) {\n          throw new Error(\n            `Array syntax cannot contain duplicate group name \"${clone.name}\" in \"${node.contextKey}\".`\n          );\n        }\n        names.add(clone.name);\n      }\n    }\n\n    const output = {\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic,\n    };\n\n    if (Array.isArray(clones)) {\n      return clones.map((clone) =>\n        applyDefaultInitialRouteName(cloneGroupRoute({ ...output }, clone))\n      );\n    }\n\n    return [\n      applyDefaultInitialRouteName({\n        loadRoute: node.loadRoute,\n        route: name,\n        contextKey: node.contextKey,\n        children: getTreeNodesAsRouteNodes(children),\n        dynamic,\n      }),\n    ];\n  }\n\n  // Empty folder, skip it.\n  if (!children.length) {\n    return null;\n  }\n\n  // When there's a directory, but no layout route file (with valid export), the child routes won't be grouped.\n  // This pushes all children into the nearest layout route.\n  return getTreeNodesAsRouteNodes(\n    children.map((child) => {\n      return {\n        ...child,\n        name: [name, child.name].filter(Boolean).join(\"/\"),\n      };\n    })\n  );\n}\n\nfunction contextModuleToFileNodes(contextModule: RequireContext): FileNode[] {\n  const nodes = contextModule.keys().map((key) => {\n    // In development, check if the file exports a default component\n    // this helps keep things snappy when creating files. In production we load all screens lazily.\n    try {\n      if (!contextModule(key)?.default) {\n        return null;\n      }\n    } catch (error) {\n      // Probably this won't stop metro from freaking out but it's worth a try.\n      console.warn('Error loading route \"' + key + '\"', error);\n      return null;\n    }\n\n    const node: FileNode = {\n      loadRoute: () => contextModule(key),\n      normalizedName: getNameFromFilePath(key),\n      contextKey: key,\n    };\n\n    return node;\n  });\n\n  return nodes.filter(Boolean) as FileNode[];\n}\n\nfunction hasCustomRootLayoutNode(routes: RouteNode[]) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  // This could either be the root _layout or an app with a single file.\n  const route = routes[0];\n\n  if (\n    route.route === \"\" &&\n    route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction treeNodesToRootRoute(treeNode: TreeNode): RouteNode | null {\n  const routes = treeNodeToRouteNode(treeNode);\n\n  if (!routes?.length) {\n    return null;\n  }\n\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n\n  return {\n    loadRoute: () => ({\n      default: (\n        require(\"./views/Navigator\") as typeof import(\"./views/Navigator\")\n      ).DefaultNavigator,\n    }),\n    // Generate a fake file name for the directory\n    contextKey: \"./_layout.tsx\",\n    route: \"\",\n\n    generated: true,\n    dynamic: null,\n    children: routes,\n  };\n}\n\n/**\n * Asserts if the require.context has files that share the same name but have different extensions. Exposed for testing.\n * @private\n */\nexport function assertDuplicateRoutes(filenames: string[]) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n\n  const duplicates = filenames\n    .map((filename) => removeSupportedExtensions(filename))\n    .reduce((acc, filename) => {\n      acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n  Object.entries(duplicates).forEach(([filename, count]) => {\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\n\n/** Given a Metro context module, return an array of nested routes. */\nexport function getRoutes(contextModule: RequireContext): RouteNode | null {\n  const route = getExactRoutes(contextModule);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\n/** Get routes without unmatched or sitemap. */\nexport function getExactRoutes(\n  contextModule: RequireContext\n): RouteNode | null {\n  assertDuplicateRoutes(contextModule.keys());\n  const files = contextModuleToFileNodes(contextModule);\n  const treeNodes = getRecursiveTree(files);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction appendSitemapRoute(routes: RouteNode) {\n  if (\n    !routes.children.length ||\n    // Allow overriding the sitemap route\n    routes.children.some((route) => route.route === \"_sitemap\")\n  ) {\n    return routes;\n  }\n  const { Sitemap, getNavOptions } = require(\"./views/Sitemap\");\n  routes.children.push({\n    loadRoute() {\n      return { default: Sitemap, getNavOptions };\n    },\n    route: \"_sitemap\",\n    contextKey: \"./_sitemap.tsx\",\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: [],\n  });\n  return routes;\n}\n\nfunction appendUnmatchedRoute(routes: RouteNode) {\n  // Auto add not found route if it doesn't exist\n  const userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute() {\n        return { default: require(\"./views/Unmatched\").Unmatched };\n      },\n      route: \"[...404]\",\n      contextKey: \"./[...404].tsx\",\n      dynamic: [{ name: \"404\", deep: true }],\n      children: [],\n      generated: true,\n      internal: true,\n    });\n  }\n  return routes;\n}\n\n/**\n * Exposed for testing.\n * @returns a top-level deep dynamic route if it exists, otherwise null.\n */\nexport function getUserDefinedDeepDynamicRoute(\n  routes: RouteNode\n): RouteNode | null {\n  // Auto add not found route if it doesn't exist\n  for (const route of routes.children ?? []) {\n    const isDeepDynamic = matchDeepDynamicRouteName(route.route);\n    if (isDeepDynamic) {\n      return route;\n    }\n    // Recurse through group routes\n    if (matchGroupName(route.route)) {\n      const child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}