{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nvar _excluded = [\"route\", \"navigation\"],\n  _excluded2 = [\"options\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport React from \"react\";\nimport { LocationProvider } from \"./LocationProvider\";\nimport { Route, sortRoutesWithInitial, useRouteNode } from \"./Route\";\nimport { Screen } from \"./primitives\";\nimport { Try } from \"./views/Try\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createElement as _createElement } from \"react\";\nfunction getSortedChildren(children, order, initialRouteName) {\n  if (!(order != null && order.length)) {\n    return children.sort(sortRoutesWithInitial(initialRouteName)).map(function (route) {\n      return {\n        route: route,\n        props: {}\n      };\n    });\n  }\n  var entries = _toConsumableArray(children);\n  var ordered = order.map(function (_ref) {\n    var name = _ref.name,\n      redirect = _ref.redirect,\n      initialParams = _ref.initialParams,\n      listeners = _ref.listeners,\n      options = _ref.options;\n    if (!entries.length) {\n      console.warn(\"[Layout children]: Too many screens defined. Route \\\"\" + name + \"\\\" is extraneous.\");\n      return null;\n    }\n    var matchIndex = entries.findIndex(function (child) {\n      return child.route === name;\n    });\n    if (matchIndex === -1) {\n      console.warn(\"[Layout children]: No route named \\\"\" + name + \"\\\" exists in nested children:\", children.map(function (_ref2) {\n        var route = _ref2.route;\n        return route;\n      }));\n      return null;\n    } else {\n      var match = entries[matchIndex];\n      entries.splice(matchIndex, 1);\n      if (redirect) {\n        if (typeof redirect === \"string\") {\n          throw new Error(\"Redirecting to a specific route is not supported yet.\");\n        }\n        return null;\n      }\n      return {\n        route: match,\n        props: {\n          initialParams: initialParams,\n          listeners: listeners,\n          options: options\n        }\n      };\n    }\n  }).filter(Boolean);\n  ordered.push.apply(ordered, _toConsumableArray(entries.sort(sortRoutesWithInitial(initialRouteName)).map(function (route) {\n    return {\n      route: route,\n      props: {}\n    };\n  })));\n  return ordered;\n}\nexport function useSortedScreens(order) {\n  var _node$children;\n  var node = useRouteNode();\n  var sorted = node != null && (_node$children = node.children) != null && _node$children.length ? getSortedChildren(node.children, order, node.initialRouteName) : [];\n  return React.useMemo(function () {\n    return sorted.map(function (value) {\n      return routeToScreen(value.route, value.props);\n    });\n  }, [sorted]);\n}\nvar qualifiedStore = new WeakMap();\nexport function getQualifiedRouteComponent(value) {\n  if (qualifiedStore.has(value)) {\n    return qualifiedStore.get(value);\n  }\n  var _value$loadRoute = value.loadRoute(),\n    Component = _value$loadRoute.default,\n    ErrorBoundary = _value$loadRoute.ErrorBoundary;\n  var QualifiedRoute = React.forwardRef(function (_ref3, ref) {\n    var route = _ref3.route,\n      navigation = _ref3.navigation,\n      props = _objectWithoutProperties(_ref3, _excluded);\n    var children = React.createElement(Component, _objectSpread(_objectSpread({}, props), {}, {\n      ref: ref,\n      segment: value.route\n    }));\n    var errorBoundary = React.useMemo(function () {\n      if (ErrorBoundary) {\n        return _jsx(Try, {\n          catch: ErrorBoundary,\n          children: children\n        });\n      }\n      return children;\n    }, [ErrorBoundary, children]);\n    return _jsx(LocationProvider, {\n      children: _jsx(Route, {\n        node: value,\n        children: errorBoundary\n      })\n    });\n  });\n  QualifiedRoute.displayName = \"Route(\" + (Component.displayName || Component.name || value.route) + \")\";\n  qualifiedStore.set(value, QualifiedRoute);\n  return QualifiedRoute;\n}\nexport function createGetIdForRoute(route) {\n  var _route$dynamic;\n  if (!((_route$dynamic = route.dynamic) != null && _route$dynamic.length)) {\n    return undefined;\n  }\n  return function (_ref4) {\n    var _route$dynamic2;\n    var params = _ref4.params;\n    var getPreferredId = function getPreferredId(segment) {\n      var preferredId = params == null ? void 0 : params[segment.name];\n      if (preferredId) {\n        if (!Array.isArray(preferredId)) {\n          return preferredId;\n        } else if (preferredId.length) {\n          return preferredId.join(\"/\");\n        }\n      }\n      return segment.deep ? \"[...\" + segment.name + \"]\" : \"[\" + segment.name + \"]\";\n    };\n    return (_route$dynamic2 = route.dynamic) == null ? void 0 : _route$dynamic2.map(function (segment) {\n      return getPreferredId(segment);\n    }).join(\"/\");\n  };\n}\nfunction routeToScreen(route) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options = _ref5.options,\n    props = _objectWithoutProperties(_ref5, _excluded2);\n  return _createElement(Screen, _objectSpread(_objectSpread({\n    getId: createGetIdForRoute(route)\n  }, props), {}, {\n    name: route.route,\n    key: route.route,\n    options: function options(args) {\n      var _route$loadRoute;\n      var staticOptions = route.generated ? (_route$loadRoute = route.loadRoute()) == null ? void 0 : _route$loadRoute.getNavOptions : null;\n      var staticResult = typeof staticOptions === \"function\" ? staticOptions(args) : staticOptions;\n      var dynamicResult = typeof _options === \"function\" ? _options == null ? void 0 : _options(args) : _options;\n      var output = _objectSpread(_objectSpread({}, staticResult), dynamicResult);\n      if (route.generated) {\n        output.tabBarButton = function () {\n          return null;\n        };\n      }\n      return output;\n    },\n    getComponent: function getComponent() {\n      return getQualifiedRouteComponent(route);\n    }\n  }));\n}","map":{"version":3,"names":["React","LocationProvider","Route","sortRoutesWithInitial","useRouteNode","Screen","Try","jsx","_jsx","createElement","_createElement","getSortedChildren","children","order","initialRouteName","length","sort","map","route","props","entries","_toConsumableArray","ordered","_ref","name","redirect","initialParams","listeners","options","console","warn","matchIndex","findIndex","child","_ref2","match","splice","Error","filter","Boolean","push","apply","useSortedScreens","_node$children","node","sorted","useMemo","value","routeToScreen","qualifiedStore","WeakMap","getQualifiedRouteComponent","has","get","_value$loadRoute","loadRoute","Component","default","ErrorBoundary","QualifiedRoute","forwardRef","_ref3","ref","navigation","_objectWithoutProperties","_excluded","_objectSpread","segment","errorBoundary","catch","displayName","set","createGetIdForRoute","_route$dynamic","dynamic","undefined","_ref4","_route$dynamic2","params","getPreferredId","preferredId","Array","isArray","join","deep","_ref5","arguments","_excluded2","getId","key","args","_route$loadRoute","staticOptions","generated","getNavOptions","staticResult","dynamicResult","output","tabBarButton","getComponent"],"sources":["C:/Riaz/Projects/JK/JK_Frontend/node_modules/expo-router/src/useScreens.tsx"],"sourcesContent":["import React from \"react\";\n\nimport { LocationProvider } from \"./LocationProvider\";\nimport {\n  DynamicConvention,\n  Route,\n  RouteNode,\n  sortRoutesWithInitial,\n  useRouteNode,\n} from \"./Route\";\nimport { Screen } from \"./primitives\";\nimport { Try } from \"./views/Try\";\n\nexport type ScreenProps<\n  TOptions extends Record<string, any> = Record<string, any>\n> = {\n  /** Name is required when used inside a Layout component. */\n  name?: string;\n  /**\n   * Redirect to the nearest sibling route.\n   * If all children are redirect={true}, the layout will render `null` as there are no children to render.\n   */\n  redirect?: boolean;\n  initialParams?: { [key: string]: any };\n  options?: TOptions;\n\n  // TODO: types\n  listeners?: any;\n};\n\nfunction getSortedChildren(\n  children: RouteNode[],\n  order?: ScreenProps[],\n  initialRouteName?: string\n): { route: RouteNode; props: Partial<ScreenProps> }[] {\n  if (!order?.length) {\n    return children\n      .sort(sortRoutesWithInitial(initialRouteName))\n      .map((route) => ({ route, props: {} }));\n  }\n  const entries = [...children];\n\n  const ordered = order\n    .map(({ name, redirect, initialParams, listeners, options }) => {\n      if (!entries.length) {\n        console.warn(\n          `[Layout children]: Too many screens defined. Route \"${name}\" is extraneous.`\n        );\n        return null;\n      }\n      const matchIndex = entries.findIndex((child) => child.route === name);\n      if (matchIndex === -1) {\n        console.warn(\n          `[Layout children]: No route named \"${name}\" exists in nested children:`,\n          children.map(({ route }) => route)\n        );\n        return null;\n      } else {\n        // Get match and remove from entries\n        const match = entries[matchIndex];\n        entries.splice(matchIndex, 1);\n\n        // Ensure to return null after removing from entries.\n        if (redirect) {\n          if (typeof redirect === \"string\") {\n            throw new Error(\n              `Redirecting to a specific route is not supported yet.`\n            );\n          }\n          return null;\n        }\n\n        return { route: match, props: { initialParams, listeners, options } };\n      }\n    })\n    .filter(Boolean) as {\n    route: RouteNode;\n    props: Partial<ScreenProps>;\n  }[];\n\n  // Add any remaining children\n  ordered.push(\n    ...entries\n      .sort(sortRoutesWithInitial(initialRouteName))\n      .map((route) => ({ route, props: {} }))\n  );\n\n  return ordered;\n}\n\n/**\n * @returns React Navigation screens sorted by the `route` property.\n */\nexport function useSortedScreens(order: ScreenProps[]): React.ReactNode[] {\n  const node = useRouteNode();\n\n  const sorted = node?.children?.length\n    ? getSortedChildren(node.children, order, node.initialRouteName)\n    : [];\n  return React.useMemo(\n    () => sorted.map((value) => routeToScreen(value.route, value.props)),\n    [sorted]\n  );\n}\n\n// TODO: Maybe there's a more React-y way to do this?\n// Without this store, the process enters a recursive loop.\nconst qualifiedStore = new WeakMap<RouteNode, React.ComponentType<any>>();\n\n/** Wrap the component with various enhancements and add access to child routes. */\nexport function getQualifiedRouteComponent(value: RouteNode) {\n  if (qualifiedStore.has(value)) {\n    return qualifiedStore.get(value)!;\n  }\n\n  const { default: Component, ErrorBoundary } = value.loadRoute();\n\n  const QualifiedRoute = React.forwardRef(\n    (\n      {\n        // Remove these React Navigation props to\n        // enforce usage of expo-router hooks (where the query params are correct).\n        route,\n        navigation,\n\n        // Pass all other props to the component\n        ...props\n      }: any,\n      ref: any\n    ) => {\n      const children = React.createElement(Component, {\n        ...props,\n        ref,\n        // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`\n        // the intention is to make it possible to deduce shared routes.\n        segment: value.route,\n      });\n\n      const errorBoundary = React.useMemo(() => {\n        if (ErrorBoundary) {\n          return <Try catch={ErrorBoundary}>{children}</Try>;\n        }\n        return children;\n      }, [ErrorBoundary, children]);\n\n      return (\n        <LocationProvider>\n          <Route node={value}>{errorBoundary}</Route>\n        </LocationProvider>\n      );\n    }\n  );\n\n  QualifiedRoute.displayName = `Route(${\n    Component.displayName || Component.name || value.route\n  })`;\n  qualifiedStore.set(value, QualifiedRoute);\n  return QualifiedRoute;\n}\n\n/** @returns a function which provides a screen id that matches the dynamic route name in params. */\nexport function createGetIdForRoute(\n  route: Pick<RouteNode, \"dynamic\" | \"route\">\n) {\n  if (!route.dynamic?.length) {\n    return undefined;\n  }\n  return ({ params }: { params?: Record<string, any> }) => {\n    const getPreferredId = (segment: DynamicConvention) => {\n      // Params can be undefined when there are no params in the route.\n      const preferredId = params?.[segment.name];\n      // If the route has a dynamic segment, use the matching parameter\n      // as the screen id. This enables pushing a screen like `/[user]` multiple times\n      // when the user is different.\n      if (preferredId) {\n        if (!Array.isArray(preferredId)) {\n          return preferredId;\n        } else if (preferredId.length) {\n          // Deep dynamic routes will return as an array, so we'll join them to create a\n          // fully qualified string.\n          return preferredId.join(\"/\");\n        }\n        // Empty arrays...\n      }\n      return segment.deep ? `[...${segment.name}]` : `[${segment.name}]`;\n    };\n    return route.dynamic?.map((segment) => getPreferredId(segment)).join(\"/\");\n  };\n}\n\nfunction routeToScreen(\n  route: RouteNode,\n  { options, ...props }: Partial<ScreenProps> = {}\n) {\n  return (\n    <Screen\n      // Users can override the screen getId function.\n      getId={createGetIdForRoute(route)}\n      {...props}\n      name={route.route}\n      key={route.route}\n      options={(args) => {\n        // Only eager load generated components\n        const staticOptions = route.generated\n          ? route.loadRoute()?.getNavOptions\n          : null;\n        const staticResult =\n          typeof staticOptions === \"function\"\n            ? staticOptions(args)\n            : staticOptions;\n        const dynamicResult =\n          typeof options === \"function\" ? options?.(args) : options;\n        const output = {\n          ...staticResult,\n          ...dynamicResult,\n        };\n\n        // Prevent generated screens from showing up in the tab bar.\n        if (route.generated) {\n          output.tabBarButton = () => null;\n        }\n\n        return output;\n      }}\n      getComponent={() => getQualifiedRouteComponent(route)}\n    />\n  );\n}\n"],"mappings":";;;;;;;AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,SAASC,gBAAgB;AACzB,SAEEC,KAAK,EAELC,qBAAqB,EACrBC,YAAY;AAEd,SAASC,MAAM;AACf,SAASC,GAAG;AAAsB,SAAAC,GAAA,IAAAC,IAAA;AAAA,SAAAC,aAAA,IAAAC,cAAA;AAmBlC,SAASC,iBAAiBA,CACxBC,QAAqB,EACrBC,KAAqB,EACrBC,gBAAyB,EAC4B;EACrD,IAAI,EAACD,KAAK,YAALA,KAAK,CAAEE,MAAM,GAAE;IAClB,OAAOH,QAAQ,CACZI,IAAI,CAACb,qBAAqB,CAACW,gBAAgB,CAAC,CAAC,CAC7CG,GAAG,CAAC,UAACC,KAAK;MAAA,OAAM;QAAEA,KAAK,EAALA,KAAK;QAAEC,KAAK,EAAE,CAAC;MAAE,CAAC;IAAA,CAAC,CAAC;EAC3C;EACA,IAAMC,OAAO,GAAAC,kBAAA,CAAOT,QAAQ,CAAC;EAE7B,IAAMU,OAAO,GAAGT,KAAK,CAClBI,GAAG,CAAC,UAAAM,IAAA,EAA2D;IAAA,IAAxDC,IAAI,GAAAD,IAAA,CAAJC,IAAI;MAAEC,QAAQ,GAAAF,IAAA,CAARE,QAAQ;MAAEC,aAAa,GAAAH,IAAA,CAAbG,aAAa;MAAEC,SAAS,GAAAJ,IAAA,CAATI,SAAS;MAAEC,OAAO,GAAAL,IAAA,CAAPK,OAAO;IACvD,IAAI,CAACR,OAAO,CAACL,MAAM,EAAE;MACnBc,OAAO,CAACC,IAAI,2DAC6CN,IAAI,uBAC5D;MACD,OAAO,IAAI;IACb;IACA,IAAMO,UAAU,GAAGX,OAAO,CAACY,SAAS,CAAC,UAACC,KAAK;MAAA,OAAKA,KAAK,CAACf,KAAK,KAAKM,IAAI;IAAA,EAAC;IACrE,IAAIO,UAAU,KAAK,CAAC,CAAC,EAAE;MACrBF,OAAO,CAACC,IAAI,0CAC4BN,IAAI,oCAC1CZ,QAAQ,CAACK,GAAG,CAAC,UAAAiB,KAAA;QAAA,IAAGhB,KAAK,GAAAgB,KAAA,CAALhB,KAAK;QAAA,OAAOA,KAAK;MAAA,EAAC,CACnC;MACD,OAAO,IAAI;IACb,CAAC,MAAM;MAEL,IAAMiB,KAAK,GAAGf,OAAO,CAACW,UAAU,CAAC;MACjCX,OAAO,CAACgB,MAAM,CAACL,UAAU,EAAE,CAAC,CAAC;MAG7B,IAAIN,QAAQ,EAAE;QACZ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;UAChC,MAAM,IAAIY,KAAK,yDAEd;QACH;QACA,OAAO,IAAI;MACb;MAEA,OAAO;QAAEnB,KAAK,EAAEiB,KAAK;QAAEhB,KAAK,EAAE;UAAEO,aAAa,EAAbA,aAAa;UAAEC,SAAS,EAATA,SAAS;UAAEC,OAAO,EAAPA;QAAQ;MAAE,CAAC;IACvE;EACF,CAAC,CAAC,CACDU,MAAM,CAACC,OAAO,CAGd;EAGHjB,OAAO,CAACkB,IAAI,CAAAC,KAAA,CAAZnB,OAAO,EAAAD,kBAAA,CACFD,OAAO,CACPJ,IAAI,CAACb,qBAAqB,CAACW,gBAAgB,CAAC,CAAC,CAC7CG,GAAG,CAAC,UAACC,KAAK;IAAA,OAAM;MAAEA,KAAK,EAALA,KAAK;MAAEC,KAAK,EAAE,CAAC;IAAE,CAAC;EAAA,CAAC,CAAC,EAC1C;EAED,OAAOG,OAAO;AAChB;AAKA,OAAO,SAASoB,gBAAgBA,CAAC7B,KAAoB,EAAqB;EAAA,IAAA8B,cAAA;EACxE,IAAMC,IAAI,GAAGxC,YAAY,EAAE;EAE3B,IAAMyC,MAAM,GAAGD,IAAI,aAAAD,cAAA,GAAJC,IAAI,CAAEhC,QAAQ,aAAd+B,cAAA,CAAgB5B,MAAM,GACjCJ,iBAAiB,CAACiC,IAAI,CAAChC,QAAQ,EAAEC,KAAK,EAAE+B,IAAI,CAAC9B,gBAAgB,CAAC,GAC9D,EAAE;EACN,OAAOd,KAAK,CAAC8C,OAAO,CAClB;IAAA,OAAMD,MAAM,CAAC5B,GAAG,CAAC,UAAC8B,KAAK;MAAA,OAAKC,aAAa,CAACD,KAAK,CAAC7B,KAAK,EAAE6B,KAAK,CAAC5B,KAAK,CAAC;IAAA,EAAC;EAAA,GACpE,CAAC0B,MAAM,CAAC,CACT;AACH;AAIA,IAAMI,cAAc,GAAG,IAAIC,OAAO,EAAuC;AAGzE,OAAO,SAASC,0BAA0BA,CAACJ,KAAgB,EAAE;EAC3D,IAAIE,cAAc,CAACG,GAAG,CAACL,KAAK,CAAC,EAAE;IAC7B,OAAOE,cAAc,CAACI,GAAG,CAACN,KAAK,CAAC;EAClC;EAEA,IAAAO,gBAAA,GAA8CP,KAAK,CAACQ,SAAS,EAAE;IAA9CC,SAAS,GAAAF,gBAAA,CAAlBG,OAAO;IAAaC,aAAa,GAAAJ,gBAAA,CAAbI,aAAa;EAEzC,IAAMC,cAAc,GAAG3D,KAAK,CAAC4D,UAAU,CACrC,UAAAC,KAAA,EAUEC,GAAQ,EACL;IAAA,IAPD5C,KAAK,GAAA2C,KAAA,CAAL3C,KAAK;MACL6C,UAAU,GAAAF,KAAA,CAAVE,UAAU;MAGP5C,KAAK,GAAA6C,wBAAA,CAAAH,KAAA,EAAAI,SAAA;IAIV,IAAMrD,QAAQ,GAAGZ,KAAK,CAACS,aAAa,CAAC+C,SAAS,EAAAU,aAAA,CAAAA,aAAA,KACzC/C,KAAK;MACR2C,GAAG,EAAHA,GAAG;MAGHK,OAAO,EAAEpB,KAAK,CAAC7B;IAAK,GACpB;IAEF,IAAMkD,aAAa,GAAGpE,KAAK,CAAC8C,OAAO,CAAC,YAAM;MACxC,IAAIY,aAAa,EAAE;QACjB,OAAOlD,IAAA,CAACF,GAAG;UAAC+D,KAAK,EAAEX,aAAc;UAAA9C,QAAA,EAAEA;QAAQ,EAAO;MACpD;MACA,OAAOA,QAAQ;IACjB,CAAC,EAAE,CAAC8C,aAAa,EAAE9C,QAAQ,CAAC,CAAC;IAE7B,OACEJ,IAAA,CAACP,gBAAgB;MAAAW,QAAA,EACfJ,IAAA,CAACN,KAAK;QAAC0C,IAAI,EAAEG,KAAM;QAAAnC,QAAA,EAAEwD;MAAa;IAAS,EAC1B;EAEvB,CAAC,CACF;EAEDT,cAAc,CAACW,WAAW,eACxBd,SAAS,CAACc,WAAW,IAAId,SAAS,CAAChC,IAAI,IAAIuB,KAAK,CAAC7B,KAAK,OACrD;EACH+B,cAAc,CAACsB,GAAG,CAACxB,KAAK,EAAEY,cAAc,CAAC;EACzC,OAAOA,cAAc;AACvB;AAGA,OAAO,SAASa,mBAAmBA,CACjCtD,KAA2C,EAC3C;EAAA,IAAAuD,cAAA;EACA,IAAI,GAAAA,cAAA,GAACvD,KAAK,CAACwD,OAAO,aAAbD,cAAA,CAAe1D,MAAM,GAAE;IAC1B,OAAO4D,SAAS;EAClB;EACA,OAAO,UAAAC,KAAA,EAAkD;IAAA,IAAAC,eAAA;IAAA,IAA/CC,MAAM,GAAAF,KAAA,CAANE,MAAM;IACd,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAIZ,OAA0B,EAAK;MAErD,IAAMa,WAAW,GAAGF,MAAM,oBAANA,MAAM,CAAGX,OAAO,CAAC3C,IAAI,CAAC;MAI1C,IAAIwD,WAAW,EAAE;QACf,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,WAAW,CAAC,EAAE;UAC/B,OAAOA,WAAW;QACpB,CAAC,MAAM,IAAIA,WAAW,CAACjE,MAAM,EAAE;UAG7B,OAAOiE,WAAW,CAACG,IAAI,CAAC,GAAG,CAAC;QAC9B;MAEF;MACA,OAAOhB,OAAO,CAACiB,IAAI,YAAUjB,OAAO,CAAC3C,IAAI,eAAU2C,OAAO,CAAC3C,IAAI,MAAG;IACpE,CAAC;IACD,QAAAqD,eAAA,GAAO3D,KAAK,CAACwD,OAAO,qBAAbG,eAAA,CAAe5D,GAAG,CAAC,UAACkD,OAAO;MAAA,OAAKY,cAAc,CAACZ,OAAO,CAAC;IAAA,EAAC,CAACgB,IAAI,CAAC,GAAG,CAAC;EAC3E,CAAC;AACH;AAEA,SAASnC,aAAaA,CACpB9B,KAAgB,EAEhB;EAAA,IAAAmE,KAAA,GAAAC,SAAA,CAAAvE,MAAA,QAAAuE,SAAA,QAAAX,SAAA,GAAAW,SAAA,MAD8C,CAAC,CAAC;EAAA,IAA9C1D,QAAO,GAAAyD,KAAA,CAAPzD,OAAO;IAAKT,KAAK,GAAA6C,wBAAA,CAAAqB,KAAA,EAAAE,UAAA;EAEnB,OACE7E,cAAA,CAACL,MAAM,EAAA6D,aAAA,CAAAA,aAAA;IAELsB,KAAK,EAAEhB,mBAAmB,CAACtD,KAAK;EAAE,GAC9BC,KAAK;IACTK,IAAI,EAAEN,KAAK,CAACA,KAAM;IAClBuE,GAAG,EAAEvE,KAAK,CAACA,KAAM;IACjBU,OAAO,EAAE,SAAAA,QAAC8D,IAAI,EAAK;MAAA,IAAAC,gBAAA;MAEjB,IAAMC,aAAa,GAAG1E,KAAK,CAAC2E,SAAS,IAAAF,gBAAA,GACjCzE,KAAK,CAACqC,SAAS,EAAE,qBAAjBoC,gBAAA,CAAmBG,aAAa,GAChC,IAAI;MACR,IAAMC,YAAY,GAChB,OAAOH,aAAa,KAAK,UAAU,GAC/BA,aAAa,CAACF,IAAI,CAAC,GACnBE,aAAa;MACnB,IAAMI,aAAa,GACjB,OAAOpE,QAAO,KAAK,UAAU,GAAGA,QAAO,oBAAPA,QAAO,CAAG8D,IAAI,CAAC,GAAG9D,QAAO;MAC3D,IAAMqE,MAAM,GAAA/B,aAAA,CAAAA,aAAA,KACP6B,YAAY,GACZC,aAAa,CACjB;MAGD,IAAI9E,KAAK,CAAC2E,SAAS,EAAE;QACnBI,MAAM,CAACC,YAAY,GAAG;UAAA,OAAM,IAAI;QAAA;MAClC;MAEA,OAAOD,MAAM;IACf,CAAE;IACFE,YAAY,EAAE,SAAAA,aAAA;MAAA,OAAMhD,0BAA0B,CAACjC,KAAK,CAAC;IAAA;EAAC,GACtD;AAEN"},"metadata":{},"sourceType":"module","externalDependencies":[]}