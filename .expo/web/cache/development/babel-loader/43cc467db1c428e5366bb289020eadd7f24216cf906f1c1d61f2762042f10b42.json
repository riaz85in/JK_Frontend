{"ast":null,"code":"import { getActionFromState } from \"@react-navigation/native\";\nimport { addEventListener, getInitialURL, getPathFromState, getStateFromPath } from \"./link/linking\";\nimport { matchDeepDynamicRouteName, matchDynamicName } from \"./matchers\";\nfunction convertDynamicRouteToReactNavigation(segment) {\n  if (segment === \"index\") {\n    return \"\";\n  }\n  var rest = matchDeepDynamicRouteName(segment);\n  if (rest != null) {\n    return \"*\" + rest;\n  }\n  var dynamicName = matchDynamicName(segment);\n  if (dynamicName != null) {\n    return \":\" + dynamicName;\n  }\n  return segment;\n}\nfunction parseRouteSegments(segments) {\n  return segments.split(\"/\").map(convertDynamicRouteToReactNavigation).filter(Boolean).join(\"/\");\n}\nfunction convertRouteNodeToScreen(node) {\n  var path = parseRouteSegments(node.route);\n  if (!node.children.length) {\n    return path;\n  }\n  var screens = getReactNavigationScreensConfig(node.children);\n  return {\n    path: path,\n    screens: screens,\n    initialRouteName: node.initialRouteName\n  };\n}\nexport function getReactNavigationScreensConfig(nodes) {\n  return Object.fromEntries(nodes.map(function (node) {\n    return [node.route, convertRouteNodeToScreen(node)];\n  }));\n}\nexport function getNavigationConfig(routes) {\n  return {\n    initialRouteName: routes.initialRouteName,\n    screens: getReactNavigationScreensConfig(routes.children)\n  };\n}\nexport function getLinkingConfig(routes) {\n  return {\n    prefixes: [],\n    config: getNavigationConfig(routes),\n    getInitialURL: getInitialURL,\n    subscribe: addEventListener,\n    getStateFromPath: getStateFromPathMemoized,\n    getPathFromState: getPathFromState,\n    getActionFromState: getActionFromState\n  };\n}\nvar stateCache = new Map();\nfunction getStateFromPathMemoized(path, options) {\n  var cached = stateCache.get(path);\n  if (cached) {\n    return cached;\n  }\n  var result = getStateFromPath(path, options);\n  stateCache.set(path, result);\n  return result;\n}","map":{"version":3,"names":["getActionFromState","addEventListener","getInitialURL","getPathFromState","getStateFromPath","matchDeepDynamicRouteName","matchDynamicName","convertDynamicRouteToReactNavigation","segment","rest","dynamicName","parseRouteSegments","segments","split","map","filter","Boolean","join","convertRouteNodeToScreen","node","path","route","children","length","screens","getReactNavigationScreensConfig","initialRouteName","nodes","Object","fromEntries","getNavigationConfig","routes","getLinkingConfig","prefixes","config","subscribe","getStateFromPathMemoized","stateCache","Map","options","cached","get","result","set"],"sources":["C:/Riaz/Projects/JK/JK_Frontend/node_modules/expo-router/src/getLinkingConfig.ts"],"sourcesContent":["import { LinkingOptions, getActionFromState } from \"@react-navigation/native\";\n\nimport { RouteNode } from \"./Route\";\nimport {\n  addEventListener,\n  getInitialURL,\n  getPathFromState,\n  getStateFromPath,\n} from \"./link/linking\";\nimport { matchDeepDynamicRouteName, matchDynamicName } from \"./matchers\";\n\ntype Screen =\n  | string\n  | {\n      path: string;\n      screens: Record<string, Screen>;\n      initialRouteName?: string;\n    };\n\n// `[page]` -> `:page`\n// `page` -> `page`\nfunction convertDynamicRouteToReactNavigation(segment: string): string {\n  // NOTE(EvanBacon): To support shared routes we preserve group segments.\n  if (segment === \"index\") {\n    return \"\";\n  }\n\n  const rest = matchDeepDynamicRouteName(segment);\n  if (rest != null) {\n    return \"*\" + rest;\n  }\n  const dynamicName = matchDynamicName(segment);\n\n  if (dynamicName != null) {\n    return `:${dynamicName}`;\n  }\n\n  return segment;\n}\n\nfunction parseRouteSegments(segments: string): string {\n  return (\n    // NOTE(EvanBacon): When there are nested routes without layouts\n    // the node.route will be something like `app/home/index`\n    // this needs to be split to ensure each segment is parsed correctly.\n    segments\n      .split(\"/\")\n      // Convert each segment to a React Navigation format.\n      .map(convertDynamicRouteToReactNavigation)\n      // Remove any empty paths from groups or index routes.\n      .filter(Boolean)\n      // Join to return as a path.\n      .join(\"/\")\n  );\n}\n\nfunction convertRouteNodeToScreen(node: RouteNode): Screen {\n  const path = parseRouteSegments(node.route);\n  if (!node.children.length) {\n    return path;\n  }\n  const screens = getReactNavigationScreensConfig(node.children);\n  return {\n    path,\n    screens,\n    // NOTE(EvanBacon): This is bad because it forces all Layout Routes\n    // to be loaded into memory. We should move towards a system where\n    // the initial route name is either loaded asynchronously in the Layout Route\n    // or defined via a file system convention.\n    initialRouteName: node.initialRouteName,\n  };\n}\n\nexport function getReactNavigationScreensConfig(\n  nodes: RouteNode[]\n): Record<string, Screen> {\n  return Object.fromEntries(\n    nodes.map((node) => [node.route, convertRouteNodeToScreen(node)] as const)\n  );\n}\n\nexport function getNavigationConfig(routes: RouteNode): {\n  initialRouteName?: string;\n  screens: Record<string, Screen>;\n} {\n  return {\n    initialRouteName: routes.initialRouteName,\n    screens: getReactNavigationScreensConfig(routes.children),\n  };\n}\n\nexport function getLinkingConfig(routes: RouteNode): LinkingOptions<object> {\n  return {\n    prefixes: [],\n    // @ts-expect-error\n    config: getNavigationConfig(routes),\n    // A custom getInitialURL is used on native to ensure the app always starts at\n    // the root path if it's launched from something other than a deep link.\n    // This helps keep the native functionality working like the web functionality.\n    // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`\n    // then `/index` would be used on web and `/settings` would be used on native.\n    getInitialURL,\n    subscribe: addEventListener,\n    getStateFromPath: getStateFromPathMemoized,\n    getPathFromState,\n\n    // Add all functions to ensure the types never need to fallback.\n    // This is a convenience for usage in the package.\n    getActionFromState,\n  };\n}\n\nconst stateCache = new Map<string, any>();\n\n/** We can reduce work by memoizing the state by the pathname. This only works because the options (linking config) theoretically never change.  */\nfunction getStateFromPathMemoized(\n  path: string,\n  options: Parameters<typeof getStateFromPath>[1]\n) {\n  const cached = stateCache.get(path);\n  if (cached) {\n    return cached;\n  }\n  const result = getStateFromPath(path, options);\n  stateCache.set(path, result);\n  return result;\n}\n"],"mappings":"AAAA,SAAyBA,kBAAkB,QAAQ,0BAA0B;AAG7E,SACEC,gBAAgB,EAChBC,aAAa,EACbC,gBAAgB,EAChBC,gBAAgB;AAElB,SAASC,yBAAyB,EAAEC,gBAAgB;AAYpD,SAASC,oCAAoCA,CAACC,OAAe,EAAU;EAErE,IAAIA,OAAO,KAAK,OAAO,EAAE;IACvB,OAAO,EAAE;EACX;EAEA,IAAMC,IAAI,GAAGJ,yBAAyB,CAACG,OAAO,CAAC;EAC/C,IAAIC,IAAI,IAAI,IAAI,EAAE;IAChB,OAAO,GAAG,GAAGA,IAAI;EACnB;EACA,IAAMC,WAAW,GAAGJ,gBAAgB,CAACE,OAAO,CAAC;EAE7C,IAAIE,WAAW,IAAI,IAAI,EAAE;IACvB,aAAWA,WAAW;EACxB;EAEA,OAAOF,OAAO;AAChB;AAEA,SAASG,kBAAkBA,CAACC,QAAgB,EAAU;EACpD,OAIEA,QAAQ,CACLC,KAAK,CAAC,GAAG,CAAC,CAEVC,GAAG,CAACP,oCAAoC,CAAC,CAEzCQ,MAAM,CAACC,OAAO,CAAC,CAEfC,IAAI,CAAC,GAAG,CAAC;AAEhB;AAEA,SAASC,wBAAwBA,CAACC,IAAe,EAAU;EACzD,IAAMC,IAAI,GAAGT,kBAAkB,CAACQ,IAAI,CAACE,KAAK,CAAC;EAC3C,IAAI,CAACF,IAAI,CAACG,QAAQ,CAACC,MAAM,EAAE;IACzB,OAAOH,IAAI;EACb;EACA,IAAMI,OAAO,GAAGC,+BAA+B,CAACN,IAAI,CAACG,QAAQ,CAAC;EAC9D,OAAO;IACLF,IAAI,EAAJA,IAAI;IACJI,OAAO,EAAPA,OAAO;IAKPE,gBAAgB,EAAEP,IAAI,CAACO;EACzB,CAAC;AACH;AAEA,OAAO,SAASD,+BAA+BA,CAC7CE,KAAkB,EACM;EACxB,OAAOC,MAAM,CAACC,WAAW,CACvBF,KAAK,CAACb,GAAG,CAAC,UAACK,IAAI;IAAA,OAAK,CAACA,IAAI,CAACE,KAAK,EAAEH,wBAAwB,CAACC,IAAI,CAAC,CAAC;EAAA,CAAS,CAAC,CAC3E;AACH;AAEA,OAAO,SAASW,mBAAmBA,CAACC,MAAiB,EAGnD;EACA,OAAO;IACLL,gBAAgB,EAAEK,MAAM,CAACL,gBAAgB;IACzCF,OAAO,EAAEC,+BAA+B,CAACM,MAAM,CAACT,QAAQ;EAC1D,CAAC;AACH;AAEA,OAAO,SAASU,gBAAgBA,CAACD,MAAiB,EAA0B;EAC1E,OAAO;IACLE,QAAQ,EAAE,EAAE;IAEZC,MAAM,EAAEJ,mBAAmB,CAACC,MAAM,CAAC;IAMnC7B,aAAa,EAAbA,aAAa;IACbiC,SAAS,EAAElC,gBAAgB;IAC3BG,gBAAgB,EAAEgC,wBAAwB;IAC1CjC,gBAAgB,EAAhBA,gBAAgB;IAIhBH,kBAAkB,EAAlBA;EACF,CAAC;AACH;AAEA,IAAMqC,UAAU,GAAG,IAAIC,GAAG,EAAe;AAGzC,SAASF,wBAAwBA,CAC/BhB,IAAY,EACZmB,OAA+C,EAC/C;EACA,IAAMC,MAAM,GAAGH,UAAU,CAACI,GAAG,CAACrB,IAAI,CAAC;EACnC,IAAIoB,MAAM,EAAE;IACV,OAAOA,MAAM;EACf;EACA,IAAME,MAAM,GAAGtC,gBAAgB,CAACgB,IAAI,EAAEmB,OAAO,CAAC;EAC9CF,UAAU,CAACM,GAAG,CAACvB,IAAI,EAAEsB,MAAM,CAAC;EAC5B,OAAOA,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}