{"ast":null,"code":"function findTopStateForTarget(state){var current=state;while(((_current=current)==null?void 0:(_current$routes=_current.routes)==null?void 0:_current$routes[((_current2=current)==null?void 0:(_current2$routes=_current2.routes)==null?void 0:_current2$routes.length)-1].state)!=null){var _current,_current$routes,_current2,_current2$routes,_current3,_current4;current=(_current3=current)==null?void 0:_current3.routes[((_current4=current)==null?void 0:_current4.routes.length)-1].state;}return current;}export function findTopRouteForTarget(state){var _nextState$routes;var nextState=findTopStateForTarget(state);return(_nextState$routes=nextState.routes)==null?void 0:_nextState$routes[nextState.routes.length-1];}export function isMovingToSiblingRoute(rootState,targetState){var current=targetState;var currentRoot=rootState;var _loop=function _loop(){var _current7,_current7$routes,_current8,_current8$routes,_nextRoute$state,_currentRoot$index,_currentRoot,_currentRoot2,_currentRoot2$routes,_currentRoot2$routes$;var nextRoute=(_current7=current)==null?void 0:(_current7$routes=_current7.routes)==null?void 0:_current7$routes[((_current8=current)==null?void 0:(_current8$routes=_current8.routes)==null?void 0:_current8$routes.length)-1];if((_nextRoute$state=nextRoute.state)!=null&&_nextRoute$state.routes.length&&!currentRoot){return{v:false};}var absCurrent=currentRoot.routes[(_currentRoot$index=(_currentRoot=currentRoot)==null?void 0:_currentRoot.index)!=null?_currentRoot$index:0];if(absCurrent.name!==nextRoute.name){return{v:false};}currentRoot=(_currentRoot2=currentRoot)==null?void 0:(_currentRoot2$routes=_currentRoot2.routes)==null?void 0:(_currentRoot2$routes$=_currentRoot2$routes.find(function(route){return route.name===nextRoute.name;}))==null?void 0:_currentRoot2$routes$.state;current=nextRoute.state;};while(((_current5=current)==null?void 0:(_current5$routes=_current5.routes)==null?void 0:_current5$routes[((_current6=current)==null?void 0:(_current6$routes=_current6.routes)==null?void 0:_current6$routes.length)-1].state)!=null){var _current5,_current5$routes,_current6,_current6$routes;var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return true;}export function getQualifiedStateForTopOfTargetState(rootState,targetState){var current=targetState;var currentRoot=rootState;var _loop2=function _loop2(){var _current11,_current11$routes,_current12,_current12$routes,_currentRoot3,_currentRoot3$routes,_currentRoot3$routes$;var nextRoute=(_current11=current)==null?void 0:(_current11$routes=_current11.routes)==null?void 0:_current11$routes[((_current12=current)==null?void 0:(_current12$routes=_current12.routes)==null?void 0:_current12$routes.length)-1];var nextCurrentRoot=(_currentRoot3=currentRoot)==null?void 0:(_currentRoot3$routes=_currentRoot3.routes)==null?void 0:(_currentRoot3$routes$=_currentRoot3$routes.find(function(route){return route.name===nextRoute.name;}))==null?void 0:_currentRoot3$routes$.state;if(nextCurrentRoot==null){return{v:currentRoot};}else{currentRoot=nextCurrentRoot;}current=nextRoute.state;};while(((_current9=current)==null?void 0:(_current9$routes=_current9.routes)==null?void 0:_current9$routes[((_current10=current)==null?void 0:(_current10$routes=_current10.routes)==null?void 0:_current10$routes.length)-1].state)!=null){var _current9,_current9$routes,_current10,_current10$routes;var _ret2=_loop2();if(typeof _ret2===\"object\")return _ret2.v;}return currentRoot;}export function getEarliestMismatchedRoute(rootState,actionParams){var _actionParams$name;var actionName=(_actionParams$name=actionParams.name)!=null?_actionParams$name:actionParams.screen;if(!(rootState!=null&&rootState.routes)||rootState.index==null){return{name:actionName,type:\"stack\"};}var nextCurrentRoot=rootState.routes[rootState.index];if(actionName===nextCurrentRoot.name){if(!actionParams.params){return null;}return getEarliestMismatchedRoute(nextCurrentRoot.state,actionParams.params);}return{name:actionName,params:actionParams.params,type:rootState.type};}","map":{"version":3,"names":["findTopStateForTarget","state","current","_current","_current$routes","routes","_current2","_current2$routes","length","_current3","_current4","findTopRouteForTarget","_nextState$routes","nextState","isMovingToSiblingRoute","rootState","targetState","currentRoot","_loop","_current7","_current7$routes","_current8","_current8$routes","_nextRoute$state","_currentRoot$index","_currentRoot","_currentRoot2","_currentRoot2$routes","_currentRoot2$routes$","nextRoute","v","absCurrent","index","name","find","route","_current5","_current5$routes","_current6","_current6$routes","_ret","getQualifiedStateForTopOfTargetState","_loop2","_current11","_current11$routes","_current12","_current12$routes","_currentRoot3","_currentRoot3$routes","_currentRoot3$routes$","nextCurrentRoot","_current9","_current9$routes","_current10","_current10$routes","_ret2","getEarliestMismatchedRoute","actionParams","_actionParams$name","actionName","screen","type","params"],"sources":["C:/Riaz/Projects/JK/JK_Frontend/node_modules/expo-router/src/link/stateOperations.ts"],"sourcesContent":["import { InitialState, NavigationState } from \"@react-navigation/native\";\n\nimport { ResultState } from \"../fork/getStateFromPath\";\n\nexport type ActionParams = {\n  params?: ActionParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n};\n\n// Get the last state for a given target state (generated from a path).\nfunction findTopStateForTarget(state: ResultState) {\n  let current: Partial<InitialState> | undefined = state;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    current = current?.routes[current?.routes.length - 1].state;\n  }\n\n  return current;\n}\n\n/** Return the absolute last route to move to. */\nexport function findTopRouteForTarget(state: ResultState) {\n  const nextState = findTopStateForTarget(state)!;\n  // Ensure we get the last route to prevent returning the initial route.\n  return nextState.routes?.[nextState.routes.length - 1]!;\n}\n\n/** @returns true if moving to a sibling inside the same navigator. */\nexport function isMovingToSiblingRoute(\n  rootState: InitialState,\n  targetState: ResultState\n): boolean {\n  let current: InitialState | undefined = targetState;\n  let currentRoot: InitialState | undefined = rootState;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    const nextRoute: any = current?.routes?.[current?.routes?.length - 1];\n\n    if (\n      // Has more\n      nextRoute.state?.routes.length &&\n      // No match\n      !currentRoot\n    ) {\n      return false;\n    }\n\n    const absCurrent = currentRoot!.routes[currentRoot?.index ?? 0];\n\n    if (absCurrent.name !== nextRoute.name) {\n      return false;\n    }\n\n    currentRoot = currentRoot?.routes?.find(\n      (route) => route.name === nextRoute.name\n    )?.state;\n\n    current = nextRoute.state;\n  }\n\n  return true;\n}\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getQualifiedStateForTopOfTargetState(\n  rootState: InitialState,\n  targetState: ResultState\n) {\n  let current: InitialState | undefined = targetState;\n  let currentRoot: InitialState | undefined = rootState;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    const nextRoute: any = current?.routes?.[current?.routes?.length - 1];\n\n    const nextCurrentRoot: InitialState | undefined = currentRoot?.routes?.find(\n      (route) => route.name === nextRoute.name\n    )?.state;\n\n    if (nextCurrentRoot == null) {\n      return currentRoot;\n      // Not sure what to do -- we're tracking against the assumption that\n      // all routes in the target state are in the root state\n      // currentRoot = undefined;\n    } else {\n      currentRoot = nextCurrentRoot;\n    }\n\n    current = nextRoute.state;\n  }\n\n  return currentRoot;\n}\n\ntype SubState = NavigationState & {\n  key?: string;\n  type: string;\n  routes?: { name: string; state?: SubState }[];\n  index?: number;\n};\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getEarliestMismatchedRoute(\n  rootState: SubState | undefined,\n  actionParams: ActionParams & { name?: string }\n): { name: string; params?: any; type?: string } | null {\n  const actionName = actionParams.name ?? actionParams.screen;\n  if (!rootState?.routes || rootState.index == null) {\n    // This should never happen where there's more action than state.\n    return {\n      name: actionName,\n      type: \"stack\",\n    };\n  }\n\n  const nextCurrentRoot = rootState.routes[rootState.index];\n  if (actionName === nextCurrentRoot.name) {\n    if (!actionParams.params) {\n      // All routes match all the way up, no change required.\n      return null;\n    }\n\n    return getEarliestMismatchedRoute(\n      nextCurrentRoot.state,\n      actionParams.params\n    );\n  }\n\n  // There's a selected state but it doesn't match the action state\n  // this is now the lowest point of change.\n  return {\n    name: actionName,\n    params: actionParams.params,\n    type: rootState.type,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}