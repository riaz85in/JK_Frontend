{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import{CommonActions,getActionFromState,NavigationContainerRefContext,StackActions}from\"@react-navigation/core\";import{TabActions}from\"@react-navigation/routers\";import*as Linking from\"expo-linking\";import*as React from\"react\";import{resolve}from\"./path\";import{findTopRouteForTarget,getEarliestMismatchedRoute,getQualifiedStateForTopOfTargetState,isMovingToSiblingRoute}from\"./stateOperations\";import{useLinkingContext}from\"./useLinkingContext\";function isRemoteHref(href){return /:\\/\\//.test(href);}export function useLinkToPath(){var navigation=React.useContext(NavigationContainerRefContext);var linking=useLinkingContext();var linkTo=React.useCallback(function(href,event){if(isRemoteHref(href)){Linking.openURL(href);return;}if(navigation==null){throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");}if(href===\"..\"||href===\"../\"){navigation.goBack();return;}if(href.startsWith(\".\")){var base=linking.getPathFromState==null?void 0:linking.getPathFromState(navigation.getRootState(),_objectSpread(_objectSpread({},linking.config),{},{preserveGroups:true}));if(base&&!base.endsWith(\"/\")){base+=\"/..\";}href=resolve(base,href);}var state=linking.getStateFromPath(href,linking.config);if(!state){console.error(\"Could not generate a valid navigation state for the given path: \"+href);return;}var rootState=navigation.getRootState();if(isMovingToSiblingRoute(rootState,state)){var knownOwnerState=getQualifiedStateForTopOfTargetState(rootState,state);var nextRoute=findTopRouteForTarget(state);if(knownOwnerState.type===\"tab\"){navigation.dispatch(TabActions.jumpTo(nextRoute.name,nextRoute.params));return;}else{if(event===\"REPLACE\"){navigation.dispatch(StackActions.replace(nextRoute.name,nextRoute.params));}else{navigation.dispatch(CommonActions.navigate(nextRoute.name,nextRoute.params));}return;}}var action=getActionFromState(state,linking.config);if(action){if(event===\"REPLACE\"&&action.type===\"NAVIGATE\"&&isAbsoluteInitialRoute(action)){var earliest=getEarliestMismatchedRoute(rootState,action.payload);if(earliest){if(earliest.type===\"stack\"){navigation.dispatch(StackActions.replace(earliest.name,earliest.params));}else{navigation.dispatch(TabActions.jumpTo(earliest.name,earliest.params));}return;}else{}}navigation.dispatch(action);}else{navigation.reset(state);}},[linking,navigation]);return linkTo;}export function isAbsoluteInitialRoute(action){if((action==null?void 0:action.type)!==\"NAVIGATE\"){return false;}var next=action.payload.params;while(next){if(!isNavigationState(next)){return false;}if(next.initial===true){next=next.params;}else if(next.initial===false){return false;}}return true;}function isNavigationState(obj){return\"initial\"in obj;}","map":{"version":3,"names":["CommonActions","getActionFromState","NavigationContainerRefContext","StackActions","TabActions","Linking","React","resolve","findTopRouteForTarget","getEarliestMismatchedRoute","getQualifiedStateForTopOfTargetState","isMovingToSiblingRoute","useLinkingContext","isRemoteHref","href","test","useLinkToPath","navigation","useContext","linking","linkTo","useCallback","event","openURL","Error","goBack","startsWith","base","getPathFromState","getRootState","_objectSpread","config","preserveGroups","endsWith","state","getStateFromPath","console","error","rootState","knownOwnerState","nextRoute","type","dispatch","jumpTo","name","params","replace","navigate","action","isAbsoluteInitialRoute","earliest","payload","reset","next","isNavigationState","initial","obj"],"sources":["C:/Riaz/Projects/JK/JK_Frontend/node_modules/expo-router/src/link/useLinkToPath.ts"],"sourcesContent":["import {\n  CommonActions,\n  getActionFromState,\n  NavigationContainerRefContext,\n  StackActions,\n} from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/routers\";\nimport * as Linking from \"expo-linking\";\nimport * as React from \"react\";\n\nimport { resolve } from \"./path\";\nimport {\n  findTopRouteForTarget,\n  getEarliestMismatchedRoute,\n  getQualifiedStateForTopOfTargetState,\n  isMovingToSiblingRoute,\n} from \"./stateOperations\";\nimport { useLinkingContext } from \"./useLinkingContext\";\n\ntype NavStateParams = {\n  params?: NavStateParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  state: unknown;\n};\n\nfunction isRemoteHref(href: string): boolean {\n  return /:\\/\\//.test(href);\n}\n\nexport function useLinkToPath() {\n  const navigation = React.useContext(NavigationContainerRefContext);\n  const linking = useLinkingContext();\n\n  const linkTo = React.useCallback(\n    (href: string, event?: string) => {\n      if (isRemoteHref(href)) {\n        Linking.openURL(href);\n        return;\n      }\n\n      if (navigation == null) {\n        throw new Error(\n          \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n        );\n      }\n\n      if (href === \"..\" || href === \"../\") {\n        navigation.goBack();\n        return;\n      }\n\n      if (href.startsWith(\".\")) {\n        let base = linking.getPathFromState?.(navigation.getRootState(), {\n          ...linking.config,\n          preserveGroups: true,\n        });\n\n        if (base && !base.endsWith(\"/\")) {\n          base += \"/..\";\n        }\n        href = resolve(base, href);\n      }\n\n      const state = linking.getStateFromPath!(href, linking!.config);\n\n      if (!state) {\n        console.error(\n          \"Could not generate a valid navigation state for the given path: \" +\n            href\n        );\n        return;\n      }\n\n      const rootState = navigation.getRootState();\n\n      // Ensure simple operations are used when moving between siblings\n      // in the same navigator. This ensures that the state is not reset.\n      // TODO: We may need to apply this at a larger scale in the future.\n      if (isMovingToSiblingRoute(rootState, state)) {\n        // Can perform naive movements\n        const knownOwnerState = getQualifiedStateForTopOfTargetState(\n          rootState,\n          state\n        )!;\n        const nextRoute = findTopRouteForTarget(state);\n\n        if (knownOwnerState.type === \"tab\") {\n          navigation.dispatch(\n            TabActions.jumpTo(nextRoute.name, nextRoute.params)\n          );\n          return;\n        } else {\n          if (event === \"REPLACE\") {\n            navigation.dispatch(\n              StackActions.replace(nextRoute.name, nextRoute.params)\n            );\n          } else {\n            // NOTE: Not sure if we should pop or push here...\n            navigation.dispatch(\n              CommonActions.navigate(nextRoute.name, nextRoute.params)\n            );\n          }\n          return;\n        }\n      }\n\n      // TODO: Advanced movements across multiple navigators\n\n      const action = getActionFromState(state, linking!.config);\n      if (action) {\n        // Here we have a navigation action to a nested screen, where we should ideally replace.\n        // This request can only be fulfilled if the target is an initial route.\n        // First, check if the action is fully initial routes.\n        // Then find the nearest mismatched route in the existing state.\n        // Finally, use the correct navigator-based action to replace the nested screens.\n        // NOTE(EvanBacon): A future version of this will involve splitting the navigation request so we replace as much as possible, then push the remaining screens to fulfill the request.\n        if (\n          event === \"REPLACE\" &&\n          action.type === \"NAVIGATE\" &&\n          isAbsoluteInitialRoute(action)\n        ) {\n          const earliest = getEarliestMismatchedRoute(\n            rootState,\n            // @ts-expect-error\n            action.payload\n          );\n          if (earliest) {\n            if (earliest.type === \"stack\") {\n              navigation.dispatch(\n                StackActions.replace(earliest.name, earliest.params)\n              );\n            } else {\n              navigation.dispatch(\n                TabActions.jumpTo(earliest.name, earliest.params)\n              );\n            }\n            return;\n          } else {\n            // This should never happen because moving to the same route would be handled earlier\n            // in the sibling operations.\n          }\n        }\n\n        // Ignore the replace event here since replace across\n        // navigators is not supported.\n        navigation.dispatch(action);\n      } else {\n        navigation.reset(state);\n      }\n    },\n    [linking, navigation]\n  );\n\n  return linkTo;\n}\n\n/** @returns `true` if the action is moving to the first screen of all the navigators in the action. */\nexport function isAbsoluteInitialRoute(\n  action: ReturnType<typeof getActionFromState>\n) {\n  if (action?.type !== \"NAVIGATE\") {\n    return false;\n  }\n\n  let next = action.payload.params;\n  // iterate all child screens and bail out if any are not initial.\n  while (next) {\n    if (!isNavigationState(next)) {\n      // Not sure when this would happen\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n      // return true;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isNavigationState(obj: any): obj is NavStateParams {\n  return \"initial\" in obj;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}