{"ast":null,"code":"import AnimatedValue from\"../core/InternalAnimatedValue\";import{createAnimatedSet as set}from\"../core/AnimatedSet\";import{createAnimatedCall as call}from\"../core/AnimatedCall\";import{createAnimatedAlways as always}from\"../core/AnimatedAlways\";import{createAnimatedCond as cond}from\"../core/AnimatedCond\";export function evaluateOnce(node){var input=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var callback=arguments.length>2?arguments[2]:undefined;if(!Array.isArray(input)){input=[input];}var done=new AnimatedValue(0);var evalNode=cond(done,0,call([node,set(done,1)],function(){callback&&callback();for(var i=0;i<input.length;i++){input[i].__removeChild(alwaysNode);alwaysNode.__detach();}}));var alwaysNode=always(evalNode);for(var i=0;i<input.length;i++){input[i].__addChild(alwaysNode);alwaysNode.__attach();}}","map":{"version":3,"names":["AnimatedValue","createAnimatedSet","set","createAnimatedCall","call","createAnimatedAlways","always","createAnimatedCond","cond","evaluateOnce","node","input","arguments","length","undefined","callback","Array","isArray","done","evalNode","i","__removeChild","alwaysNode","__detach","__addChild","__attach"],"sources":["C:/Riaz/Projects/JK/JK_Frontend/node_modules/react-native-reanimated/lib/reanimated1/derived/evaluateOnce.js"],"sourcesContent":["import AnimatedValue from '../core/InternalAnimatedValue';\nimport { createAnimatedSet as set } from '../core/AnimatedSet';\nimport { createAnimatedCall as call } from '../core/AnimatedCall';\nimport { createAnimatedAlways as always } from '../core/AnimatedAlways';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\n\n/**\n * evaluate given node and notify children\n * @param node - node to be evaluated\n * @param input - nodes (or one node) representing values which states input for node.\n * @param callback - after callback\n */\n\nexport function evaluateOnce(node, input = [], callback) {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  const done = new AnimatedValue(0);\n  const evalNode = cond(\n    done,\n    0,\n    call([node, set(done, 1)], () => {\n      callback && callback();\n      for (let i = 0; i < input.length; i++) {\n        input[i].__removeChild(alwaysNode);\n        alwaysNode.__detach();\n      }\n    })\n  );\n  const alwaysNode = always(evalNode);\n  for (let i = 0; i < input.length; i++) {\n    input[i].__addChild(alwaysNode);\n    alwaysNode.__attach();\n  }\n}\n"],"mappings":"AAAA,MAAO,CAAAA,aAAa,qCACpB,OAASC,iBAAiB,GAAI,CAAAC,GAAG,2BACjC,OAASC,kBAAkB,GAAI,CAAAC,IAAI,4BACnC,OAASC,oBAAoB,GAAI,CAAAC,MAAM,8BACvC,OAASC,kBAAkB,GAAI,CAAAC,IAAI,4BASnC,MAAO,SAAS,CAAAC,YAAYA,CAACC,IAAI,CAAwB,IAAtB,CAAAC,KAAK,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,EAAE,IAAE,CAAAG,QAAQ,CAAAH,SAAA,CAAAC,MAAA,GAAAD,SAAA,IAAAE,SAAA,CACrD,GAAI,CAACE,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,CAAE,CACzBA,KAAK,CAAG,CAACA,KAAK,CAAC,CACjB,CACA,GAAM,CAAAO,IAAI,CAAG,GAAI,CAAAlB,aAAa,CAAC,CAAC,CAAC,CACjC,GAAM,CAAAmB,QAAQ,CAAGX,IAAI,CACnBU,IAAI,CACJ,CAAC,CACDd,IAAI,CAAC,CAACM,IAAI,CAAER,GAAG,CAACgB,IAAI,CAAE,CAAC,CAAC,CAAC,CAAE,UAAM,CAC/BH,QAAQ,EAAIA,QAAQ,EAAE,CACtB,IAAK,GAAI,CAAAK,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGT,KAAK,CAACE,MAAM,CAAEO,CAAC,EAAE,CAAE,CACrCT,KAAK,CAACS,CAAC,CAAC,CAACC,aAAa,CAACC,UAAU,CAAC,CAClCA,UAAU,CAACC,QAAQ,EAAE,CACvB,CACF,CAAC,CAAC,CACH,CACD,GAAM,CAAAD,UAAU,CAAGhB,MAAM,CAACa,QAAQ,CAAC,CACnC,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGT,KAAK,CAACE,MAAM,CAAEO,CAAC,EAAE,CAAE,CACrCT,KAAK,CAACS,CAAC,CAAC,CAACI,UAAU,CAACF,UAAU,CAAC,CAC/BA,UAAU,CAACG,QAAQ,EAAE,CACvB,CACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}