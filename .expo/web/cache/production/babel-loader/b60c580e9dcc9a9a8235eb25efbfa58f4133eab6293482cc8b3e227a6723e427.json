{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import{findFocusedRoute,validatePathConfig}from\"@react-navigation/core\";import escape from\"escape-string-regexp\";import*as queryString from\"query-string\";import{matchGroupName,stripGroupSegmentsFromPath}from\"../matchers\";function getPathname(path){var remaining=path.replace(/\\/+/g,\"/\").replace(/^\\//,\"\").replace(/\\?.*$/,\"\");return remaining.endsWith(\"/\")?remaining:remaining+\"/\";}export default function getStateFromPath(path,options){if(options){validatePathConfig(options);}var screens=options==null?void 0:options.screens;if(!screens){throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");}var initialRoutes=[];if(options!=null&&options.initialRouteName){initialRoutes.push({initialRouteName:options.initialRouteName,parentScreens:[]});}var converted=Object.keys(screens).map(function(key){return createNormalizedConfigs(key,screens,[],initialRoutes);}).flat();var resolvedInitialPatterns=initialRoutes.map(function(route){return joinPaths.apply(void 0,_toConsumableArray(route.parentScreens).concat([route.initialRouteName]));});var convertedWithInitial=converted.map(function(config){return _objectSpread(_objectSpread({},config),{},{isInitial:resolvedInitialPatterns.includes(config.routeNames.join(\"/\"))});});var configs=convertedWithInitial.sort(sortConfigs);assertConfigDuplicates(configs);return getStateFromPathWithConfigs(path,configs,initialRoutes);}function assertConfigDuplicates(configs){configs.reduce(function(acc,config){var _config$regex$toStrin,_config$regex;var indexedKey=(_config$regex$toStrin=(_config$regex=config.regex)==null?void 0:_config$regex.toString())!=null?_config$regex$toStrin:config.pattern;var alpha=acc[indexedKey];if(alpha&&!alpha.hasChildren&&!config.hasChildren){var a=alpha.routeNames;var b=config.routeNames;var intersects=a.length>b.length?b.every(function(it,i){return a[i]===it;}):a.every(function(it,i){return b[i]===it;});if(!intersects){var last=config.pattern.split(\"/\").pop();var routeType=last!=null&&last.startsWith(\":\")?\"dynamic route\":last!=null&&last.startsWith(\"*\")?\"dynamic-rest route\":\"route\";throw new Error(\"The \"+routeType+\" pattern '\"+(config.pattern||\"/\")+\"' resolves to both '\"+alpha.userReadableName+\"' and '\"+config.userReadableName+\"'. Patterns must be unique and cannot resolve to more than one route.\");}}return Object.assign(acc,_defineProperty({},indexedKey,config));},{});}function sortConfigs(a,b){if(a.pattern===b.pattern){return b.routeNames.join(\">\").localeCompare(a.routeNames.join(\">\"));}if(a.pattern.startsWith(b.pattern)&&b.screen!==\"index\"){return-1;}if(b.pattern.startsWith(a.pattern)&&a.screen!==\"index\"){return 1;}var aParts=a.pattern.split(\"/\").filter(function(part){return matchGroupName(part)==null;});if(a.screen===\"index\"){aParts.push(\"index\");}var bParts=b.pattern.split(\"/\").filter(function(part){return matchGroupName(part)==null;});if(b.screen===\"index\"){bParts.push(\"index\");}for(var i=0;i<Math.max(aParts.length,bParts.length);i++){if(aParts[i]==null){return 1;}if(bParts[i]==null){return-1;}var aWildCard=aParts[i].startsWith(\"*\");var bWildCard=bParts[i].startsWith(\"*\");if(aWildCard&&bWildCard){continue;}if(aWildCard){return 1;}if(bWildCard){return-1;}var aSlug=aParts[i].startsWith(\":\");var bSlug=bParts[i].startsWith(\":\");if(aSlug&&bSlug){continue;}if(aSlug){return 1;}if(bSlug){return-1;}}if(a.isInitial&&!b.isInitial){return-1;}if(!a.isInitial&&b.isInitial){return 1;}return bParts.length-aParts.length;}function getStateFromEmptyPathWithConfigs(path,configs,initialRoutes){var _ref,_leafNodes$find;var leafNodes=configs.filter(function(config){return!config.hasChildren;}).map(function(value){return _objectSpread(_objectSpread({},value),{},{path:stripGroupSegmentsFromPath(value.path)});});var match=(_ref=(_leafNodes$find=leafNodes.find(function(config){return config.path===\"\"&&(!config.regex||config.regex.test(\"\"));}))!=null?_leafNodes$find:leafNodes.find(function(config){return config.path.startsWith(\":\")&&config.regex.test(\"\");}))!=null?_ref:leafNodes.find(function(config){return config.path.startsWith(\"*\")&&config.regex.test(\"/\");});if(!match){return undefined;}var routes=match.routeNames.map(function(name){return{name:name};});return createNestedStateObject(path,routes,configs,initialRoutes);}function getStateFromPathWithConfigs(path,configs,initialRoutes){var pathname=getPathname(path);if(pathname===\"/\"){return getStateFromEmptyPathWithConfigs(path,configs,initialRoutes);}var routes=matchAgainstConfigs(pathname,configs.map(function(c){return _objectSpread(_objectSpread({},c),{},{regex:c.regex?new RegExp(c.regex.source+\"$\"):undefined});}));if(routes==null){return undefined;}return createNestedStateObject(path,routes,configs,initialRoutes);}var joinPaths=function joinPaths(){var _ref2;for(var _len=arguments.length,paths=new Array(_len),_key=0;_key<_len;_key++){paths[_key]=arguments[_key];}return(_ref2=[]).concat.apply(_ref2,_toConsumableArray(paths.map(function(p){return p.split(\"/\");}))).filter(Boolean).join(\"/\");};function matchAgainstConfigs(remaining,configs){var routes;var remainingPath=remaining;var _loop=function _loop(){var _config$pattern;if(!config.regex){return\"continue\";}var match=remainingPath.match(config.regex);if(!match){return\"continue\";}var matchedParams=(_config$pattern=config.pattern)==null?void 0:_config$pattern.split(\"/\").filter(function(p){return p.match(/^[:*]/);}).reduce(function(acc,p,i){var _ref3;if(p.match(/^\\*/)){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},p,match[(i+1)*2]));}return Object.assign(acc,_defineProperty({},p,(_ref3=match[(i+1)*2])==null?void 0:_ref3.replace(/\\//,\"\")));},{});var routeFromName=function routeFromName(name){var config=configs.find(function(c){return c.screen===name;});if(!(config!=null&&config.path)){return{name:name};}var segments=config.path.split(\"/\");var params={};segments.filter(function(p){return p.match(/^[:*]/);}).forEach(function(p){var value=matchedParams[p];if(value){var _config$parse;if(p.match(/^\\*/)){var _value;value=(_value=value)==null?void 0:_value.split(\"/\").filter(Boolean);}var key=p.replace(/^[:*]/,\"\").replace(/\\?$/,\"\");params[key]=(_config$parse=config.parse)!=null&&_config$parse[key]?config.parse[key](value):value;}});if(params&&Object.keys(params).length){return{name:name,params:params};}return{name:name};};routes=config.routeNames.map(function(name){return routeFromName(name);});var combinedParams=routes.reduce(function(acc,r){return Object.assign(acc,r.params);},{});var hasCombinedParams=Object.keys(combinedParams).length>0;routes=routes.map(function(r){if(hasCombinedParams){r.params=combinedParams;}return r;});remainingPath=remainingPath.replace(match[1],\"\");return\"break\";};for(var config of configs){var _ret=_loop();if(_ret===\"continue\")continue;if(_ret===\"break\")break;}return routes;}function equalHeritage(a,b){if(a.length!==b.length){return false;}for(var i=0;i<a.length;i++){if(a[i].localeCompare(b[i])!==0){return false;}}return true;}var createNormalizedConfigs=function createNormalizedConfigs(screen,routeConfig){var routeNames=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var initials=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];var parentScreens=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];var parentPattern=arguments.length>5?arguments[5]:undefined;var configs=[];routeNames.push(screen);parentScreens.push(screen);var config=routeConfig[screen];if(typeof config===\"string\"){var pattern=parentPattern?joinPaths(parentPattern,config):config;configs.push(createConfigItem(screen,routeNames,pattern,config,false));}else if(typeof config===\"object\"){var _pattern;if(typeof config.path===\"string\"){var _Object$keys;if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}_pattern=config.exact!==true?joinPaths(parentPattern||\"\",config.path||\"\"):config.path||\"\";configs.push(createConfigItem(screen,routeNames,_pattern,config.path,config.screens?!!((_Object$keys=Object.keys(config.screens))!=null&&_Object$keys.length):false,config.parse));}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,parentScreens:parentScreens});}Object.keys(config.screens).forEach(function(nestedConfig){var _pattern2;var result=createNormalizedConfigs(nestedConfig,config.screens,routeNames,initials,_toConsumableArray(parentScreens),(_pattern2=_pattern)!=null?_pattern2:parentPattern);configs.push.apply(configs,_toConsumableArray(result));});}}routeNames.pop();return configs;};function formatRegexPattern(it){it=it.replace(\" \",\"%20\");if(it.startsWith(\":\")){return\"(([^/]+\\\\/)\"+(it.endsWith(\"?\")?\"?\":\"\")+\")\";}else if(it.startsWith(\"*\")){return\"((.*\\\\/)\"+(it.endsWith(\"?\")?\"?\":\"\")+\")\";}if(matchGroupName(it)!=null){return\"(?:\"+escape(it)+\"\\\\/)?\";}return escape(it)+\"\\\\/\";}var createConfigItem=function createConfigItem(screen,routeNames,pattern,path,hasChildren,parse){pattern=pattern.split(\"/\").filter(Boolean).join(\"/\");var regex=pattern?new RegExp(\"^(\"+pattern.split(\"/\").map(formatRegexPattern).join(\"\")+\")\"):undefined;return{screen:screen,regex:regex,pattern:pattern,path:path,routeNames:_toConsumableArray(routeNames),parse:parse,userReadableName:[].concat(_toConsumableArray(routeNames.slice(0,-1)),[path||screen]).join(\"/\"),hasChildren:!!hasChildren};};var findParseConfigForRoute=function findParseConfigForRoute(routeName,routeConfigs){for(var config of routeConfigs){if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};var findInitialRoute=function findInitialRoute(routeName,parentScreens,initialRoutes){for(var config of initialRoutes){if(equalHeritage(parentScreens,config.parentScreens)){return routeName!==config.initialRouteName?config.initialRouteName:undefined;}}return undefined;};var createStateObject=function createStateObject(initialRoute,route,isEmpty){if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},route]};}return{routes:[route]};}if(initialRoute){return{index:1,routes:[{name:initialRoute},_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};}return{routes:[_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};};var createNestedStateObject=function createNestedStateObject(path,routes,routeConfigs,initialRoutes){var route=routes.shift();var parentScreens=[];var initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);parentScreens.push(route.name);var state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){var nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);var nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}parentScreens.push(route.name);}}route=findFocusedRoute(state);route.path=stripGroupSegmentsFromPath(path);var params=parseQueryParams(route.path,findParseConfigForRoute(route.name,routeConfigs));if(params){var resolvedParams=_objectSpread(_objectSpread({},route.params),params);if(Object.keys(resolvedParams).length>0){route.params=resolvedParams;}else{delete route.params;}}return state;};var parseQueryParams=function parseQueryParams(path,parseConfig){var query=path.split(\"?\")[1];var params=queryString.parse(query);if(parseConfig){Object.keys(params).forEach(function(name){if(Object.hasOwnProperty.call(parseConfig,name)&&typeof params[name]===\"string\"){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;};","map":{"version":3,"names":["findFocusedRoute","validatePathConfig","escape","queryString","matchGroupName","stripGroupSegmentsFromPath","getPathname","path","remaining","replace","endsWith","getStateFromPath","options","screens","Error","initialRoutes","initialRouteName","push","parentScreens","converted","Object","keys","map","key","createNormalizedConfigs","flat","resolvedInitialPatterns","route","joinPaths","apply","_toConsumableArray","concat","convertedWithInitial","config","_objectSpread","isInitial","includes","routeNames","join","configs","sort","sortConfigs","assertConfigDuplicates","getStateFromPathWithConfigs","reduce","acc","_config$regex$toStrin","_config$regex","indexedKey","regex","toString","pattern","alpha","hasChildren","a","b","intersects","length","every","it","i","last","split","pop","routeType","startsWith","userReadableName","assign","_defineProperty","localeCompare","screen","aParts","filter","part","bParts","Math","max","aWildCard","bWildCard","aSlug","bSlug","getStateFromEmptyPathWithConfigs","_ref","_leafNodes$find","leafNodes","value","match","find","test","undefined","routes","name","createNestedStateObject","pathname","matchAgainstConfigs","c","RegExp","source","_ref2","_len","arguments","paths","Array","_key","p","Boolean","remainingPath","_loop","_config$pattern","matchedParams","_ref3","routeFromName","segments","params","forEach","_config$parse","_value","parse","combinedParams","r","hasCombinedParams","_ret","equalHeritage","routeConfig","initials","parentPattern","createConfigItem","_Object$keys","exact","nestedConfig","_pattern2","result","formatRegexPattern","slice","findParseConfigForRoute","routeName","routeConfigs","findInitialRoute","createStateObject","initialRoute","isEmpty","index","state","shift","nestedState","nestedStateIndex","parseQueryParams","resolvedParams","parseConfig","query","hasOwnProperty","call"],"sources":["C:/Riaz/Projects/JK/JK_Frontend/node_modules/expo-router/src/fork/getStateFromPath.ts"],"sourcesContent":["import {\n  PathConfigMap,\n  findFocusedRoute,\n  validatePathConfig,\n} from \"@react-navigation/core\";\nimport type {\n  InitialState,\n  NavigationState,\n  PartialState,\n} from \"@react-navigation/routers\";\nimport escape from \"escape-string-regexp\";\nimport * as queryString from \"query-string\";\n\nimport { matchGroupName, stripGroupSegmentsFromPath } from \"../matchers\";\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  isInitial?: boolean;\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n  hasChildren: boolean;\n  userReadableName: string;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any> | undefined;\n};\n\nfunction getPathname(path: string) {\n  const remaining = path\n    .replace(/\\/+/g, \"/\") // Replace multiple slash (//) with single ones\n    .replace(/^\\//, \"\") // Remove extra leading slash\n    .replace(/\\?.*$/, \"\"); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  return remaining.endsWith(\"/\") ? remaining : `${remaining}/`;\n}\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath<ParamList extends object>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const screens = options?.screens;\n  // Expo Router disallows usage without a linking config.\n  if (!screens) {\n    throw Error(\n      \"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\"\n    );\n  }\n\n  // This will be mutated...\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  // Create a normalized configs array which will be easier to use.\n  const converted = Object.keys(screens)\n    .map((key) => createNormalizedConfigs(key, screens, [], initialRoutes))\n    .flat();\n\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  const convertedWithInitial = converted.map((config) => ({\n    ...config,\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    isInitial: resolvedInitialPatterns.includes(config.routeNames.join(\"/\")),\n  }));\n\n  // Sort in order of resolution. This is extremely important for the algorithm to work.\n  const configs = convertedWithInitial.sort(sortConfigs);\n\n  // Assert any duplicates before we start parsing.\n  assertConfigDuplicates(configs);\n\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\n\nfunction assertConfigDuplicates(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    // NOTE(EvanBacon): Uses the regex pattern as key to detect duplicate slugs.\n    const indexedKey = config.regex?.toString() ?? config.pattern;\n    const alpha = acc[indexedKey];\n    // NOTE(EvanBacon): Skips checking nodes that have children.\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      const a = alpha.routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length\n          ? b.every((it, i) => a[i] === it)\n          : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        // NOTE(EvanBacon): Adds more context to the error message since we know about the\n        // file-based routing.\n        const last = config.pattern.split(\"/\").pop();\n        const routeType = last?.startsWith(\":\")\n          ? \"dynamic route\"\n          : last?.startsWith(\"*\")\n          ? \"dynamic-rest route\"\n          : \"route\";\n        throw new Error(\n          `The ${routeType} pattern '${\n            config.pattern || \"/\"\n          }' resolves to both '${alpha.userReadableName}' and '${\n            config.userReadableName\n          }'. Patterns must be unique and cannot resolve to more than one route.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [indexedKey]: config,\n    });\n  }, {});\n}\n\nfunction sortConfigs(a: RouteConfig, b: RouteConfig): number {\n  // Sort config so that:\n  // - the most exhaustive ones are always at the beginning\n  // - patterns with wildcard are always at the end\n\n  // If 2 patterns are same, move the one with less route names up\n  // This is an error state, so it's only useful for consistent error messages\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join(\">\").localeCompare(a.routeNames.join(\">\"));\n  }\n\n  // If one of the patterns starts with the other, it's more exhaustive\n  // So move it up\n  if (\n    a.pattern.startsWith(b.pattern) &&\n    // NOTE(EvanBacon): This is a hack to make sure that `*` is always at the end\n    b.screen !== \"index\"\n  ) {\n    return -1;\n  }\n\n  if (b.pattern.startsWith(a.pattern) && a.screen !== \"index\") {\n    return 1;\n  }\n\n  // NOTE(EvanBacon): Here we append `index` if the screen was `index` so the length is the same\n  // as a slug or wildcard when nested more than one level deep.\n  // This is so we can compare the length of the pattern, e.g. `foo/*` > `foo` vs `*` < ``.\n  const aParts = a.pattern\n    .split(\"/\")\n    // Strip out group names to ensure they don't affect the priority.\n    .filter((part) => matchGroupName(part) == null);\n  if (a.screen === \"index\") {\n    aParts.push(\"index\");\n  }\n\n  const bParts = b.pattern\n    .split(\"/\")\n    .filter((part) => matchGroupName(part) == null);\n  if (b.screen === \"index\") {\n    bParts.push(\"index\");\n  }\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    // if b is longer, b get higher priority\n    if (aParts[i] == null) {\n      return 1;\n    }\n    // if a is longer, a get higher priority\n    if (bParts[i] == null) {\n      return -1;\n    }\n    const aWildCard = aParts[i].startsWith(\"*\");\n    const bWildCard = bParts[i].startsWith(\"*\");\n    // if both are wildcard we compare next component\n    if (aWildCard && bWildCard) {\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aWildCard) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bWildCard) {\n      return -1;\n    }\n\n    const aSlug = aParts[i].startsWith(\":\");\n    const bSlug = bParts[i].startsWith(\":\");\n    // if both are wildcard we compare next component\n    if (aSlug && bSlug) {\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aSlug) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bSlug) {\n      return -1;\n    }\n  }\n\n  // Sort initial routes with a higher priority than routes which will push more screens\n  // this ensures shared routes go to the shortest path.\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n\n  return bParts.length - aParts.length;\n}\n\nfunction getStateFromEmptyPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === \"\" && (!config.regex || config.regex.test(\"\"))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(\":\") && config.regex!.test(\"\")\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find(\n      (config) => config.path.startsWith(\"*\") && config.regex!.test(\"/\")\n    );\n\n  if (!match) {\n    return undefined;\n  }\n\n  const routes = match.routeNames.map((name) => ({ name }));\n\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\n\nfunction getStateFromPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  const pathname = getPathname(path);\n\n  if (pathname === \"/\") {\n    return getStateFromEmptyPathWithConfigs(path, configs, initialRoutes);\n  }\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const routes = matchAgainstConfigs(\n    pathname,\n    configs.map((c) => ({\n      ...c,\n      // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n      regex: c.regex ? new RegExp(c.regex.source + \"$\") : undefined,\n    }))\n  );\n\n  if (routes == null) {\n    return undefined;\n  }\n  // This will always be empty if full path matched\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split(\"/\")))\n    .filter(Boolean)\n    .join(\"/\");\n\nfunction matchAgainstConfigs(\n  remaining: string,\n  configs: RouteConfig[]\n): ParsedRoute[] | undefined {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (!match) {\n      continue;\n    }\n\n    // TODO: Add support for wildcard routes\n    const matchedParams = config.pattern\n      ?.split(\"/\")\n      .filter((p) => p.match(/^[:*]/))\n      .reduce<Record<string, any>>((acc, p, i) => {\n        if (p.match(/^\\*/)) {\n          return {\n            ...acc,\n            [p]: match![(i + 1) * 2], //?.replace(/\\//, \"\"),\n          };\n        }\n        return Object.assign(acc, {\n          // The param segments appear every second item starting from 2 in the regex match result.\n          // This will only work if we ensure groups aren't included in the match.\n          [p]: match![(i + 1) * 2]?.replace(/\\//, \"\"),\n        });\n      }, {});\n\n    const routeFromName = (name: string) => {\n      const config = configs.find((c) => c.screen === name);\n      if (!config?.path) {\n        return { name };\n      }\n\n      const segments = config.path.split(\"/\");\n\n      const params: Record<string, any> = {};\n\n      segments\n        .filter((p) => p.match(/^[:*]/))\n        .forEach((p) => {\n          let value = matchedParams[p];\n          if (value) {\n            if (p.match(/^\\*/)) {\n              // Convert to an array before providing as a route.\n              value = value?.split(\"/\").filter(Boolean);\n            }\n\n            const key = p.replace(/^[:*]/, \"\").replace(/\\?$/, \"\");\n            params[key] = config.parse?.[key]\n              ? config.parse[key](value)\n              : value;\n          }\n        });\n\n      if (params && Object.keys(params).length) {\n        return { name, params };\n      }\n\n      return { name };\n    };\n\n    routes = config.routeNames.map((name) => routeFromName(name));\n\n    // TODO(EvanBacon): Maybe we should warn / assert if multiple slugs use the same param name.\n    const combinedParams = routes.reduce<Record<string, any>>(\n      (acc, r) => Object.assign(acc, r.params),\n      {}\n    );\n\n    const hasCombinedParams = Object.keys(combinedParams).length > 0;\n\n    // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\n    routes = routes.map((r) => {\n      if (hasCombinedParams) {\n        r.params = combinedParams;\n      }\n      return r;\n    });\n\n    remainingPath = remainingPath.replace(match[1], \"\");\n\n    break;\n  }\n\n  return routes;\n}\n\nfunction equalHeritage(a: string[], b: string[]): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[] = [],\n  parentScreens: string[] = [],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  // @ts-expect-error\n  const config = routeConfig[screen];\n\n  if (typeof config === \"string\") {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === \"object\") {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === \"string\") {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || \"\", config.path || \"\")\n          : config.path || \"\";\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.screens ? !!Object.keys(config.screens)?.length : false,\n          config.parse\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(\" \", \"%20\");\n\n  if (it.startsWith(\":\")) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith(\"?\") ? \"?\" : \"\"})`;\n  } else if (it.startsWith(\"*\")) {\n    return `((.*\\\\/)${it.endsWith(\"?\") ? \"?\" : \"\"})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  hasChildren?: boolean,\n  parse?: ParseConfig\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split(\"/\").filter(Boolean).join(\"/\");\n\n  const regex = pattern\n    ? new RegExp(`^(${pattern.split(\"/\").map(formatRegexPattern).join(\"\")})`)\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join(\"/\"),\n    hasChildren: !!hasChildren,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  routeConfigs: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      // If the parents are the same but the route name doesn't match the initial route\n      // then we return the initial route.\n      return routeName !== config.initialRouteName\n        ? config.initialRouteName\n        : undefined;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    }\n    return {\n      routes: [route],\n    };\n  }\n\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n    };\n  }\n  return {\n    routes: [{ ...route, state: { routes: [] } }],\n  };\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  routeConfigs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(\n    initialRoute,\n    route,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n\n  // Remove groups from the path while preserving a trailing slash.\n  route.path = stripGroupSegmentsFromPath(path);\n\n  const params = parseQueryParams(\n    route.path,\n    findParseConfigForRoute(route.name, routeConfigs)\n  );\n\n  if (params) {\n    const resolvedParams = { ...route.params, ...params };\n    if (Object.keys(resolvedParams).length > 0) {\n      route.params = resolvedParams;\n    } else {\n      delete route.params;\n    }\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) => {\n  const query = path.split(\"?\")[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (\n        Object.hasOwnProperty.call(parseConfig, name) &&\n        typeof params[name] === \"string\"\n      ) {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}